<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【UVM学习笔记】UVM基础—一文告诉你UVM的组成部分 | ElemenX-king</title><meta name="author" content="Elemen"><meta name="copyright" content="Elemen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="一、Driver驱动器这段代码是用 SystemVerilog 编写的一个基于 UVM（Universal Verification Methodology）的驱动器（driver）组件，名为 my_driver。它继承自 uvm_driver 类，用于在验证环境中驱动 DUT（Design Under Test，被测设计）的输入信号。下面我将逐步解释这段代码的结构和功能。 1.1 整体结构">
<meta property="og:type" content="article">
<meta property="og:title" content="【UVM学习笔记】UVM基础—一文告诉你UVM的组成部分">
<meta property="og:url" content="https://www.elemenx-king.xyz/2025/04/16/675312ec1441/index.html">
<meta property="og:site_name" content="ElemenX-king">
<meta property="og:description" content="一、Driver驱动器这段代码是用 SystemVerilog 编写的一个基于 UVM（Universal Verification Methodology）的驱动器（driver）组件，名为 my_driver。它继承自 uvm_driver 类，用于在验证环境中驱动 DUT（Design Under Test，被测设计）的输入信号。下面我将逐步解释这段代码的结构和功能。 1.1 整体结构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.elemenx-king.xyz/img/cover2.png">
<meta property="article:published_time" content="2025-04-16T03:41:38.000Z">
<meta property="article:modified_time" content="2025-04-18T07:15:14.922Z">
<meta property="article:author" content="Elemen">
<meta property="article:tag" content="UVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.elemenx-king.xyz/img/cover2.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【UVM学习笔记】UVM基础—一文告诉你UVM的组成部分",
  "url": "https://www.elemenx-king.xyz/2025/04/16/675312ec1441/",
  "image": "https://www.elemenx-king.xyz/img/cover2.png",
  "datePublished": "2025-04-16T03:41:38.000Z",
  "dateModified": "2025-04-18T07:15:14.922Z",
  "author": [
    {
      "@type": "Person",
      "name": "Elemen",
      "url": "https://www.elemenx-king.xyz/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon_cat.ico"><link rel="canonical" href="https://www.elemenx-king.xyz/2025/04/16/675312ec1441/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#2c1a28')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":260,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Elemen","link":"链接: ","source":"来源: ElemenX-king","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【UVM学习笔记】UVM基础—一文告诉你UVM的组成部分',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-color: #e8d4d0;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/black_cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover2.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/black_cat_a.png" alt="Logo"><span class="site-name">ElemenX-king</span></a><a class="nav-page-title" href="/"><span class="site-name">【UVM学习笔记】UVM基础—一文告诉你UVM的组成部分</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【UVM学习笔记】UVM基础—一文告诉你UVM的组成部分</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-16T03:41:38.000Z" title="发表于 2025-04-16 11:41:38">2025-04-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-18T07:15:14.922Z" title="更新于 2025-04-18 15:15:14">2025-04-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/UVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">UVM学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-04-18 15:15:14&quot;}" hidden></div><meta name="referrer" content="no-referrer"/>

<hr>
<h1 id="一、Driver驱动器"><a href="#一、Driver驱动器" class="headerlink" title="一、Driver驱动器"></a>一、Driver驱动器</h1><p>这段代码是用 SystemVerilog 编写的一个基于 UVM（Universal Verification Methodology）的驱动器（driver）组件，名为 my_driver。它继承自 uvm_driver 类，用于在验证环境中驱动 DUT（Design Under Test，被测设计）的输入信号。下面我将逐步解释这段代码的结构和功能。</p>
<h2 id="1-1-整体结构"><a href="#1-1-整体结构" class="headerlink" title="1.1 整体结构"></a>1.1 整体结构</h2><p>代码分为两个主要部分：</p>
<ul>
<li>类定义部分：定义了 my_driver 类，包括构造函数和一个外部声明的任务（main_phase）。</li>
<li>任务实现部分：实现了 main_phase 任务，负责具体的信号驱动逻辑。</li>
</ul>
<p>此外，代码使用 ifndef 和 define 宏来防止重复包含。</p>
<h2 id="1-2-详细解释"><a href="#1-2-详细解释" class="headerlink" title="1.2 详细解释"></a>1.2 详细解释</h2><h3 id="1-2-1-宏定义保护"><a href="#1-2-1-宏定义保护" class="headerlink" title="1.2.1 宏定义保护"></a>1.2.1 宏定义保护</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifndef MY_DRIVER__SV</span><br><span class="line">define MY_DRIVER__SV</span><br></pre></td></tr></table></figure>
<p>检查是否已经定义了宏MY_DRIVER__SV。如果没有定义，则编译器会继续处理后面的代码。<br>最后，文件末尾的 endif 与开头的 ifndef 配对，结束条件编译块。</p>
<h3 id="1-2-2-类定义"><a href="#1-2-2-类定义" class="headerlink" title="1.2.2 类定义"></a>1.2.2 类定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_driver</span> <span class="keyword">extends</span> <span class="title class_">uvm_driver</span>;</span><br><span class="line">   function <span class="title function_">new</span><span class="params">(string name = <span class="string">&quot;my_driver&quot;</span>, uvm_component parent = <span class="literal">null</span>)</span>;</span><br><span class="line">      <span class="built_in">super</span>.new(name, parent);</span><br><span class="line">   endfunction</span><br><span class="line">   extern virtual task <span class="title function_">main_phase</span><span class="params">(uvm_phase phase)</span>;</span><br><span class="line">endclass</span><br></pre></td></tr></table></figure>
<p>class my_driver extends uvm_driver：定义一个名为 my_driver 的类，并且表示 my_driver 继承自 UVM 提供的基类 uvm_driver。<br>uvm_driver 是 UVM 框架中的一个标准组件类，用于将事务级数据转换为 DUT 的引脚级信号。</p>
<blockquote>
<p>事务级数据是指更高层次的抽象数据，通常以结构体或类的形式表示，而不是直接的硬件信号（0 和 1）。它描述的是“做什么”，而不是“怎么做”。<br>假设事务是一个 8 位数据 8’b10100101。<br>驱动器将其转换为：<br>top_tb.rxd &lt;&#x3D; 8’b10100101;（数据信号）<br>top_tb.rx_dv &lt;&#x3D; 1’b1;（有效信号）<br>并在 @(posedge top_tb.clk) 时更新这些信号。</p>
</blockquote>
<p><code>function new</code>：定义类的构造函数，用于创建 my_driver 对象。<br><code>super.new(name, parent)</code>：调用父类 uvm_driver 的构造函数，将 name 和 parent 参数传递给它。这是 UVM 中面向对象编程的标准做法，确保父类的初始化逻辑被执行。<br><code>extern</code>：表示 main_phase 任务的实现不在类定义内部，而是在外部单独定义。<br><code>virtual</code>：声明这是一个虚任务，允许子类重写（override）它。这是 UVM 中 phase 方法的常见做法。<br><code>task main_phase(uvm_phase phase)</code>：定义一个名为 main_phase 的任务，接收一个 uvm_phase 类型的参数 phase，表示 UVM 的仿真阶段（这里是 main_phase，通常用于主要的测试执行阶段）。</p>
<h3 id="1-2-3-任务实现"><a href="#1-2-3-任务实现" class="headerlink" title="1.2.3 任务实现"></a>1.2.3 任务实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">task my_driver::main_phase(uvm_phase phase);</span><br><span class="line">   top_tb.rxd &lt;= <span class="number">8</span><span class="string">&#x27;b0;</span></span><br><span class="line"><span class="string">   top_tb.rx_dv &lt;= 1&#x27;</span>b0;</span><br><span class="line">   <span class="keyword">while</span>(!top_tb.rst_n)</span><br><span class="line">      @(posedge top_tb.clk);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)begin</span><br><span class="line">      @(posedge top_tb.clk);</span><br><span class="line">      top_tb.rxd &lt;= $urandom_range(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">      top_tb.rx_dv &lt;= <span class="number">1</span><span class="string">&#x27;b1;</span></span><br><span class="line"><span class="string">      `uvm_info(&quot;my_driver&quot;, &quot;data is drived&quot;, UVM_LOW)</span></span><br><span class="line"><span class="string">   end</span></span><br><span class="line"><span class="string">   @(posedge top_tb.clk);</span></span><br><span class="line"><span class="string">   top_tb.rx_dv &lt;= 1&#x27;</span>b0;</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
<p><code>my_driver::main_phase</code>：明确指定这个任务是 my_driver 类的一部分。<br>这是 main_phase 的具体实现，负责驱动 DUT 的信号。<br>uvm_info(“my_driver”, “data is drived”, UVM_LOW)：<br>UVM 提供的日志记录宏，打印信息。<br><code>my_driver</code>：消息来源（组件名）。<br><code>data is drived</code>：消息内容。<br><code>UVM_LOW</code>：日志级别，表示低详细程度。<br>作用：在 256 个时钟周期内，连续向 DUT 的 rxd 输入随机数据，并将 rx_dv 置为 1，同时记录日志。</p>
<blockquote>
<p>所谓类的定义,就是用编辑器写下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&gt;...</span><br><span class="line">&gt;endclass</span><br></pre></td></tr></table></figure>
<p>而所谓类的实例化指的是通过new创造出A的一个实例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;A a_list;</span><br><span class="line">&gt;a_list = <span class="keyword">new</span>();</span><br></pre></td></tr></table></figure></blockquote>
<h3 id="1-2-4-factory机制"><a href="#1-2-4-factory机制" class="headerlink" title="1.2.4 factory机制"></a>1.2.4 factory机制</h3><p>factory机制的实现被集成在了一个宏中：uvm_component_utils。这个宏所做的事情非常多，其中之一就是将my_driver登记在UVM内部的一张表中，这张表是 factory 功能实现的基础。只要在定义一个新的类时使用这个宏，就相当于把这个类注册到了这张表中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`uvm_component_utils(my_driver)</span><br></pre></td></tr></table></figure>
<p>在给driver中加入factory机制后，还需要对top_tb做一些改动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initial begin</span><br><span class="line">	<span class="title function_">run_test</span><span class="params">(<span class="string">&quot;my_driver&quot;</span>)</span>;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>但是输出的结果只有两个，没有执行后面的代码，关于这个问题，牵涉UVM的objection机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UVM_INFO my_driver.sv(<span class="number">8</span>) @ <span class="number">0</span>: uvm_test_top [my_driver] <span class="keyword">new</span> <span class="title class_">is</span> called</span><br><span class="line">UVM_INFO @ <span class="number">0</span>: reporter [RNTST] Running test my_driver...</span><br><span class="line">UVM_INFO my_driver.sv(<span class="number">14</span>) @ <span class="number">0</span>: uvm_test_top [my_driver] main_phase is called</span><br></pre></td></tr></table></figure>
<h3 id="1-2-4-objection机制"><a href="#1-2-4-objection机制" class="headerlink" title="1.2.4 objection机制"></a>1.2.4 objection机制</h3><p>UVM中通过objection机制来控制验证平台的关闭。细心的读者可能发现，在上节的例子中，并没有如2.2.1节所示显式地调用 finish 语句来结束仿真。但是在运行上节例子时，仿真平台确实关闭了。在每个phase中，UVM会检查是否有objection被提起  (raise_objection)，如果有，那么等待这个objection被撤销(drop_objection)后停止仿真；如果没有，则马上结束当前 phase。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task my_driver::main_phase(uvm_phase phase);</span><br><span class="line">   phase.raise_objection(<span class="built_in">this</span>);</span><br><span class="line">	...</span><br><span class="line">   phase.drop_objection(<span class="built_in">this</span>);</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
<p>raise_objection语句必须在main_phase中第一个消耗仿真时间的语句之前。	</p>
<h3 id="1-2-5-加入virtual-interface"><a href="#1-2-5-加入virtual-interface" class="headerlink" title="1.2.5 加入virtual interface"></a>1.2.5 加入virtual interface</h3><p>使用该方法能够杜绝因为绝对路径所带来的不便，在SystemVerilog中使用interface来连接验证平台与DUT的端口，该端口可以认为是一种总线。<br>定义interface的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">`ifndef MY_IF__SV</span><br><span class="line">`define MY_IF__SV</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">my_if</span>(input clk, input rst_n);</span><br><span class="line">   logic [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line">   logic valid;</span><br><span class="line">endinterface</span><br><span class="line"></span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
<p>因为my_driver是一个类，在类中不能使用声明的方法定义一个  interface，只有在类似top_tb这样的模块(module)中才可以。在类中使用的是virtual interface：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual my_if vif;</span><br></pre></td></tr></table></figure>
<p>因此在 中就可以使用该方法来使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">task my_driver::main_phase(uvm_phase phase);</span><br><span class="line">   phase.raise_objection(<span class="built_in">this</span>);</span><br><span class="line">   `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;main_phase is called&quot;</span>, UVM_LOW);</span><br><span class="line">   vif.data &lt;= <span class="number">8</span><span class="string">&#x27;b0; </span></span><br><span class="line"><span class="string">   vif.valid &lt;= 1&#x27;</span>b0;</span><br><span class="line">   <span class="keyword">while</span>(!vif.rst_n)</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)begin</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">      vif.data &lt;= $urandom_range(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">      vif.valid &lt;= <span class="number">1</span><span class="string">&#x27;b1;</span></span><br><span class="line"><span class="string">      `uvm_info(&quot;my_driver&quot;, &quot;data is drived&quot;, UVM_LOW);</span></span><br><span class="line"><span class="string">   end</span></span><br><span class="line"><span class="string">   @(posedge vif.clk);</span></span><br><span class="line"><span class="string">   vif.valid &lt;= 1&#x27;</span>b0;</span><br><span class="line">   phase.drop_objection(<span class="built_in">this</span>);</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
<p>下面的问题是，如何把top_tb中的input_if和my_driver中的vif对应起来。<br>针对该问题，UVM引进了config_db机制。在config_db机制中，分为set和get两步操作。set就是读取数据，get就是输出数据。在top_tb中的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initial begin</span><br><span class="line">   uvm_config_db#(virtual my_if)::set(<span class="literal">null</span>, <span class="string">&quot;uvm_test_top&quot;</span>, <span class="string">&quot;vif&quot;</span>, input_if);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>在my_driver中的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">virtual function <span class="keyword">void</span> <span class="title function_">build_phase</span><span class="params">(uvm_phase phase)</span>;</span><br><span class="line">   <span class="built_in">super</span>.build_phase(phase);</span><br><span class="line">   `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;build_phase is called&quot;</span>, UVM_LOW);</span><br><span class="line">   <span class="keyword">if</span>(!uvm_config_db#(virtual my_if)::get(<span class="built_in">this</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;vif&quot;</span>, vif))</span><br><span class="line">      `uvm_fatal(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;virtual interface must be set for vif!!!&quot;</span>)</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<p>首先build_phase也是内置函数，build_phase在new函数之后main_phase之前执行。其中的super.build_phase语句是因为在其父类的build_phase中执行了一些必要的操作。<br>其中还出现了uvm_fatal宏，其与uvm_info的作用类似。uvm_fatal的出现表示验证平台出现了重大问题而无法继续下去,必须停止仿真并做相应的检查。<br>config_db的set和get函数都有四个参数，这两个函数的第三个参数必须完全一致。</p>
<ul>
<li>set函数的第四个参数表示要将哪个interface通过config_db传递给my_driver</li>
<li>get函数的第四个参数表示把得到的interface传递给哪个my_driver的成员变量。</li>
</ul>
<p>set函数的第二个参数表示的是路径索引，UVM通过run_test语句创建一个名字为uvm_test_top的实例，因此需要输入uvm_test_top。无论传递给run_test的参数是什么,创建的实例的名字都为uvm_test_top。其他两个参数以后再说。<br>set函数与get函数使用双冒号是因为这两个函数都是静态函数，而前面的#键是要传递的类型,这里是virtual my_if。</p>
<h1 id="二、transaction组件"><a href="#二、transaction组件" class="headerlink" title="二、transaction组件"></a>二、transaction组件</h1><p>transaction就是一个提供数据传输的打包操作。在不同的验证平台中,会有不同的transaction。一个简单的transaction的定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">`ifndef MY_TRANSACTION__SV</span><br><span class="line">`define MY_TRANSACTION__SV</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_transaction</span> <span class="keyword">extends</span> <span class="title class_">uvm_sequence_item</span>;</span><br><span class="line"></span><br><span class="line">   rand bit[<span class="number">47</span>:<span class="number">0</span>] dmac;</span><br><span class="line">   rand bit[<span class="number">47</span>:<span class="number">0</span>] smac;</span><br><span class="line">   rand bit[<span class="number">15</span>:<span class="number">0</span>] ether_type;</span><br><span class="line">   rand <span class="type">byte</span>      pload[];</span><br><span class="line">   rand bit[<span class="number">31</span>:<span class="number">0</span>] crc;</span><br><span class="line"></span><br><span class="line">   constraint pload_cons&#123;</span><br><span class="line">      pload.size &gt;= <span class="number">46</span>;</span><br><span class="line">      pload.size &lt;= <span class="number">1500</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function bit[<span class="number">31</span>:<span class="number">0</span>] calc_crc();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">32</span><span class="string">&#x27;h0;</span></span><br><span class="line"><span class="string">   endfunction</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   function void post_randomize();</span></span><br><span class="line"><span class="string">      crc = calc_crc;</span></span><br><span class="line"><span class="string">   endfunction</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   `uvm_object_utils(my_transaction)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   function new(string name = &quot;my_transaction&quot;);</span></span><br><span class="line"><span class="string">      super.new();</span></span><br><span class="line"><span class="string">   endfunction</span></span><br><span class="line"><span class="string">endclass</span></span><br><span class="line"><span class="string">`endif</span></span><br></pre></td></tr></table></figure>
<p>其中dmac和smac模拟的就是发送地址和接受地址，ether_type是以太网类型，pload是其携带数据的大小。下面的函数是用于约束上述数据的。通过pload_cons约束将其大小被限制在46~1500byte，CRC暂且使用post_randomize中加的一个空函数calc_crc来对其定义，有兴趣的读者可以将其补充完整。</p>
<blockquote>
<p>post_randomize是SystemVerilog中提供的一个函数，当某个类的实例的randomize函数被调用后,post_randomize会紧随其后无条件地被调用。</p>
</blockquote>
<p>在transaction定义中，有两点值得引起注意：</p>
<ol>
<li>my_transaction的基类是uvm_sequence_item。<br>在UVM中,所有的transaction都要从uvm_sequence_item派生</li>
<li>是这里没有使用uvm_component_utils宏来实现factory机制，而是使用了uvm_object_utils。</li>
</ol>
<p>下面便是使用transaction的my_driver代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">task my_driver::main_phase(uvm_phase phase);</span><br><span class="line">   my_transaction tr;</span><br><span class="line">   phase.raise_objection(<span class="built_in">this</span>);</span><br><span class="line">   vif.data &lt;= <span class="number">8</span><span class="string">&#x27;b0;</span></span><br><span class="line"><span class="string">   vif.valid &lt;= 1&#x27;</span>b0;</span><br><span class="line">   <span class="keyword">while</span>(!vif.rst_n)</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) <span class="type">begin</span> </span><br><span class="line">      <span class="variable">tr</span> <span class="operator">=</span> <span class="keyword">new</span>(<span class="string">&quot;tr&quot;</span>);</span><br><span class="line">      <span class="keyword">assert</span>(tr.randomize() with &#123;pload.size == <span class="number">200</span>;&#125;);</span><br><span class="line">      drive_one_pkt(tr);</span><br><span class="line">   end</span><br><span class="line">   <span class="title function_">repeat</span><span class="params">(<span class="number">5</span>)</span> @(posedge vif.clk);</span><br><span class="line">   phase.drop_objection(<span class="built_in">this</span>);</span><br><span class="line">endtask</span><br><span class="line"></span><br><span class="line">task my_driver::drive_one_pkt(my_transaction tr);</span><br><span class="line">   bit [<span class="number">47</span>:<span class="number">0</span>] tmp_data;</span><br><span class="line">   bit [<span class="number">7</span>:<span class="number">0</span>] data_q[$]; </span><br><span class="line">  </span><br><span class="line">   <span class="comment">//push dmac to data_q</span></span><br><span class="line">   tmp_data = tr.dmac;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) begin</span><br><span class="line">      data_q.push_back(tmp_data[<span class="number">7</span>:<span class="number">0</span>]);</span><br><span class="line">      tmp_data = (tmp_data &gt;&gt; <span class="number">8</span>);</span><br><span class="line">   end</span><br><span class="line">   <span class="comment">//push smac to data_q</span></span><br><span class="line">   <span class="comment">//push ether_type to data_q</span></span><br><span class="line">   <span class="comment">//push payload to data_q</span></span><br><span class="line">   <span class="comment">//push crc to data_q</span></span><br><span class="line"></span><br><span class="line">   `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;begin to drive one pkt&quot;</span>, UVM_LOW);</span><br><span class="line">   repeat(<span class="number">3</span>) @(posedge vif.clk);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(data_q.size() &gt; <span class="number">0</span>) begin</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">      vif.valid &lt;= <span class="number">1</span><span class="string">&#x27;b1;</span></span><br><span class="line"><span class="string">      vif.data &lt;= data_q.pop_front(); </span></span><br><span class="line"><span class="string">   end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   @(posedge vif.clk);</span></span><br><span class="line"><span class="string">   vif.valid &lt;= 1&#x27;</span>b0;</span><br><span class="line">   `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;end drive one pkt&quot;</span>, UVM_LOW);</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
<p>在main_phase中，先使用randomize将tr随机化，之后通过drive_one_pkt任务将tr的内容驱动到DUT的端口上。<br>在drive_one_pkt中，先将tr中所有的数据压入队列data_q中，之后再将data_q中所有的数据弹出输入到DUT端口上。</p>
<h1 id="三、env组件"><a href="#三、env组件" class="headerlink" title="三、env组件"></a>三、env组件</h1><p>为了能够更好的实例化my_dirver等组件，需要有一个容器去把他们装在一起，这个容器就是env，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">`ifndef MY_ENV__SV</span><br><span class="line">`define MY_ENV__SV</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_env</span> <span class="keyword">extends</span> <span class="title class_">uvm_env</span>;</span><br><span class="line"></span><br><span class="line">   my_driver drv;</span><br><span class="line"></span><br><span class="line">   function <span class="title function_">new</span><span class="params">(string name = <span class="string">&quot;my_env&quot;</span>, uvm_component parent)</span>;</span><br><span class="line">      <span class="built_in">super</span>.new(name, parent);</span><br><span class="line">   endfunction</span><br><span class="line"></span><br><span class="line">   virtual function <span class="keyword">void</span> <span class="title function_">build_phase</span><span class="params">(uvm_phase phase)</span>;</span><br><span class="line">      <span class="built_in">super</span>.build_phase(phase);</span><br><span class="line">      drv = my_driver::type_id::create(<span class="string">&quot;drv&quot;</span>, <span class="built_in">this</span>); </span><br><span class="line">   endfunction</span><br><span class="line"></span><br><span class="line">   `uvm_component_utils(my_env)</span><br><span class="line">endclass</span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
<p>在my_env的定义中，使用了区别于new的方式，只有使用这种方式实例化的实例，验证平台中的组件在实例化时都应该使用type_name::type_id::create的方式。<br>回顾一下my_driver的new函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">new</span><span class="params">(string name = <span class="string">&quot;my_driver&quot;</span>, uvm_component parent = <span class="literal">null</span>)</span>; </span><br><span class="line">	<span class="built_in">super</span>.new(name, parent); </span><br><span class="line">endfuncti</span><br></pre></td></tr></table></figure>
<p>可以看出 my_driver 的父结点就是my_env。通过parent的形式，UVM建立起了树形的组织结构。在这种树形的组织结构中，由run_test创建的实例是树根，并且树根的名字是固定的为uvm_test_top，长出枝叶的过程需要在my_env的build_phase中手动实现。<br>无论是树根还是树叶，都必须由 uvm_component 或者其派生类继承而来。整棵UVM树的结构如图所示。</p>
<div align=center>
<img src="https://i-blog.csdnimg.cn/direct/2e7b6a7f3cf44aebacd2edf67b18d061.png" height=250>
</div>
在UVM的树形结构中，build_phase的执行遵照从树根到树叶的顺序。
在top_tb中使用config_db机制传递virtual  my_if时，要改变相应的路径；同时，run_test的参数也从my_driver变为了my_env。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">initial begin</span><br><span class="line">   <span class="title function_">run_test</span><span class="params">(<span class="string">&quot;my_env&quot;</span>)</span>;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">initial begin</span><br><span class="line">   uvm_config_db#(virtual my_if)::set(<span class="literal">null</span>, <span class="string">&quot;uvm_test_top.drv&quot;</span>, <span class="string">&quot;vif&quot;</span>, input_if);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
set函数的第二个参数从uvm_test_top变为了uvm_test_top.drv，其中uvm_test_top是UVM自动创建的树根的名字，而drv则是在my_env的build_phase中实例化drv时传递过去的名字。
# 四、monitor组件
验证平台中实现监测DUT行为的组件是monitor，其主要功能起到一个监测作用。其将用于收集DUT的端口数据，并将其转换成transaction交给后续的组件处理。代码如下：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">`ifndef MY_MONITOR__SV</span><br><span class="line">`define MY_MONITOR__SV</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_monitor</span> <span class="keyword">extends</span> <span class="title class_">uvm_monitor</span>;</span><br><span class="line">   virtual my_if vif;</span><br><span class="line">   `uvm_component_utils(my_monitor)</span><br><span class="line">   function <span class="title function_">new</span><span class="params">(string name = <span class="string">&quot;my_monitor&quot;</span>, uvm_component parent = <span class="literal">null</span>)</span>;</span><br><span class="line">      <span class="built_in">super</span>.new(name, parent);</span><br><span class="line">   endfunction</span><br><span class="line">   virtual function <span class="keyword">void</span> <span class="title function_">build_phase</span><span class="params">(uvm_phase phase)</span>;</span><br><span class="line">      <span class="built_in">super</span>.build_phase(phase);</span><br><span class="line">      <span class="keyword">if</span>(!uvm_config_db#(virtual my_if)::get(<span class="built_in">this</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;vif&quot;</span>, vif))</span><br><span class="line">         `uvm_fatal(<span class="string">&quot;my_monitor&quot;</span>, <span class="string">&quot;virtual interface must be set for vif!!!&quot;</span>)</span><br><span class="line">   endfunction</span><br><span class="line">   extern task <span class="title function_">main_phase</span><span class="params">(uvm_phase phase)</span>;</span><br><span class="line">   extern task <span class="title function_">collect_one_pkt</span><span class="params">(my_transaction tr)</span>;</span><br><span class="line">endclass</span><br><span class="line">task my_monitor::main_phase(uvm_phase phase);</span><br><span class="line">   my_transaction tr;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) <span class="type">begin</span></span><br><span class="line">      <span class="variable">tr</span> <span class="operator">=</span> <span class="keyword">new</span>(<span class="string">&quot;tr&quot;</span>);</span><br><span class="line">      collect_one_pkt(tr);</span><br><span class="line">   end</span><br><span class="line">endtask</span><br><span class="line">task my_monitor::collect_one_pkt(my_transaction tr);</span><br><span class="line">   bit[<span class="number">7</span>:<span class="number">0</span>] data_q[$]; </span><br><span class="line">   <span class="type">int</span> psize;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) begin</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">      <span class="keyword">if</span>(vif.valid) <span class="keyword">break</span>;</span><br><span class="line">   end</span><br><span class="line">   `uvm_info(<span class="string">&quot;my_monitor&quot;</span>, <span class="string">&quot;begin to collect one pkt&quot;</span>, UVM_LOW);</span><br><span class="line">   <span class="keyword">while</span>(vif.valid) begin</span><br><span class="line">      data_q.push_back(vif.data);</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">   end</span><br><span class="line">   <span class="comment">//pop dmac</span></span><br><span class="line">   <span class="comment">//pop smac</span></span><br><span class="line">   <span class="comment">//pop ether_type</span></span><br><span class="line">   <span class="comment">//pop payload</span></span><br><span class="line">   <span class="comment">//pop crc</span></span><br><span class="line">   `uvm_info(<span class="string">&quot;my_monitor&quot;</span>, <span class="string">&quot;end collect one pkt, print it:&quot;</span>, UVM_LOW);</span><br><span class="line">    tr.my_print();</span><br><span class="line">endtask</span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
该代码与my_driver非常相似。其主要工作与my_driver相反，my_driver用于产生驱动信号，而该模块则用于收集。
最后要在evn中进行实例化：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">virtual function <span class="keyword">void</span> <span class="title function_">build_phase</span><span class="params">(uvm_phase phase)</span>;</span><br><span class="line">   <span class="built_in">super</span>.build_phase(phase);</span><br><span class="line">   drv = my_driver::type_id::create(<span class="string">&quot;drv&quot;</span>, <span class="built_in">this</span>); </span><br><span class="line">   i_mon = my_monitor::type_id::create(<span class="string">&quot;i_mon&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">   o_mon = my_monitor::type_id::create(<span class="string">&quot;o_mon&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
需要注意的是这里定义了两个my_monitor模块，一个收集输入的，另一个收集输出的。树形结构如下所示：

<div align=center>
<img src="https://i-blog.csdnimg.cn/direct/6a95bda1540841519687a48c87f6b982.png" height=250 >
</div>

<h1 id="五、agent组件"><a href="#五、agent组件" class="headerlink" title="五、agent组件"></a>五、agent组件</h1><p>因为my_monitor和my_dirver有相似性，因此可以将两者封装在一起，使用agent组件，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">`ifndef MY_AGENT__SV</span><br><span class="line">`define MY_AGENT__SV</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_agent</span> <span class="keyword">extends</span> <span class="title class_">uvm_agent</span> ;</span><br><span class="line">   my_driver     drv;</span><br><span class="line">   my_monitor    mon;</span><br><span class="line">   </span><br><span class="line">   function <span class="title function_">new</span><span class="params">(string name, uvm_component parent)</span>;</span><br><span class="line">      <span class="built_in">super</span>.new(name, parent);</span><br><span class="line">   endfunction </span><br><span class="line">   </span><br><span class="line">   extern virtual function <span class="keyword">void</span> <span class="title function_">build_phase</span><span class="params">(uvm_phase phase)</span>;</span><br><span class="line">   extern virtual function <span class="keyword">void</span> <span class="title function_">connect_phase</span><span class="params">(uvm_phase phase)</span>;</span><br><span class="line"></span><br><span class="line">   `uvm_component_utils(my_agent)</span><br><span class="line">endclass </span><br><span class="line"></span><br><span class="line">function <span class="keyword">void</span> my_agent::build_phase(uvm_phase phase);</span><br><span class="line">   <span class="built_in">super</span>.build_phase(phase);</span><br><span class="line">   <span class="keyword">if</span> (is_active == UVM_ACTIVE) <span class="type">begin</span></span><br><span class="line">       <span class="variable">drv</span> <span class="operator">=</span> my_driver::type_id::create(<span class="string">&quot;drv&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">   <span class="type">end</span></span><br><span class="line">   <span class="variable">mon</span> <span class="operator">=</span> my_monitor::type_id::create(<span class="string">&quot;mon&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">endfunction </span><br><span class="line"></span><br><span class="line">function <span class="keyword">void</span> my_agent::connect_phase(uvm_phase phase);</span><br><span class="line">   <span class="built_in">super</span>.connect_phase(phase);</span><br><span class="line">endfunction</span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里有一点比较疑惑，为什么build_phase和connect_phase要在外面定义？为什么不在里面？</p>
</blockquote>
<p>里面的is_active相当于一个宏定义，用于判断是否实例化dirver，比如再输入的时候需要实例化去驱动，但是在输出就不需要。因此，env的代码就变成下面的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">virtual function <span class="keyword">void</span> <span class="title function_">build_phase</span><span class="params">(uvm_phase phase)</span>;</span><br><span class="line">   <span class="built_in">super</span>.build_phase(phase);</span><br><span class="line">   i_agt = my_agent::type_id::create(<span class="string">&quot;i_agt&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">   o_agt = my_agent::type_id::create(<span class="string">&quot;o_agt&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">   i_agt.is_active = UVM_ACTIVE;</span><br><span class="line">   o_agt.is_active = UVM_PASSIVE;</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<p>UVM_ACTIVE和UVM_PASSIVE是两个枚举。UVM树形结构变成下面这样：</p>
<div align=center>
<img src="https://i-blog.csdnimg.cn/direct/dca1a8311f1645eea8269ee8d46ad625.png" height=250 >
</div>

<h1 id="五、reference-model组件"><a href="#五、reference-model组件" class="headerlink" title="五、reference model组件"></a>五、reference model组件</h1><p>reference model用于完成和DUT相同的功能，用于与设计的验证平台在后面的计分板上做对比。改模块的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">`ifndef MY_MODEL__SV</span><br><span class="line">`define MY_MODEL__SV</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_model</span> <span class="keyword">extends</span> <span class="title class_">uvm_component</span>;</span><br><span class="line">   </span><br><span class="line">   uvm_blocking_get_port #(my_transaction)  port;</span><br><span class="line">   uvm_analysis_port #(my_transaction)  ap;</span><br><span class="line"></span><br><span class="line">   extern function <span class="title function_">new</span><span class="params">(string name, uvm_component parent)</span>;</span><br><span class="line">   extern function <span class="keyword">void</span> <span class="title function_">build_phase</span><span class="params">(uvm_phase phase)</span>;</span><br><span class="line">   extern virtual  task <span class="title function_">main_phase</span><span class="params">(uvm_phase phase)</span>;</span><br><span class="line"></span><br><span class="line">   `uvm_component_utils(my_model)</span><br><span class="line">endclass </span><br><span class="line"></span><br><span class="line">function my_model::<span class="keyword">new</span>(string name, uvm_component parent);</span><br><span class="line">   <span class="built_in">super</span>.new(name, parent);</span><br><span class="line">endfunction </span><br><span class="line"></span><br><span class="line">function <span class="keyword">void</span> my_model::build_phase(uvm_phase phase);</span><br><span class="line">   <span class="built_in">super</span>.build_phase(phase);</span><br><span class="line">   port = <span class="keyword">new</span>(<span class="string">&quot;port&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">   ap = <span class="keyword">new</span>(<span class="string">&quot;ap&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">task my_model::main_phase(uvm_phase phase);</span><br><span class="line">   my_transaction tr;</span><br><span class="line">   my_transaction new_tr;</span><br><span class="line">   <span class="built_in">super</span>.main_phase(phase);</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) begin</span><br><span class="line">      port.get(tr);</span><br><span class="line">      new_tr = <span class="keyword">new</span>(<span class="string">&quot;new_tr&quot;</span>);</span><br><span class="line">      new_tr.my_copy(tr);</span><br><span class="line">      `uvm_info(<span class="string">&quot;my_model&quot;</span>, <span class="string">&quot;get one transaction, copy and print it:&quot;</span>, UVM_LOW)</span><br><span class="line">      new_tr.my_print();</span><br><span class="line">      ap.write(new_tr);</span><br><span class="line">   end</span><br><span class="line">endtask</span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
<p>可以看出，其主要就是复制了一份tr从ap到port。<br>但是其中的难点在于如何将 my_model 与其他模块进行通信。在UVM中,通常使用TLM(Transaction Level Modeling)实现component之间transaction级别  的通信。得到的UVM树形图如下所示：</p>
<div align=center>
<img src="https://i-blog.csdnimg.cn/direct/34cc566007d74a9bab7dae60f0c05ca3.png" height=250 >
</div>

<p>这里需要注意数据流动的方向，是从i_agt流动到mdl，而数据是i_agt中的my_monitor。因此在 my_monitor 需要定义一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uvm_analysis_port #(my_transaction)  ap;</span><br><span class="line">   virtual function <span class="keyword">void</span> <span class="title function_">build_phase</span><span class="params">(uvm_phase phase)</span>;</span><br><span class="line">...</span><br><span class="line">      ap = <span class="keyword">new</span>(<span class="string">&quot;ap&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">   endfunction</span><br><span class="line">   </span><br><span class="line">task my_monitor::main_phase(uvm_phase phase);</span><br><span class="line">   my_transaction tr;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) <span class="type">begin</span></span><br><span class="line">      <span class="variable">tr</span> <span class="operator">=</span> <span class="keyword">new</span>(<span class="string">&quot;tr&quot;</span>);</span><br><span class="line">      collect_one_pkt(tr);</span><br><span class="line">      ap.write(tr);</span><br><span class="line">   end</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
<p>uvm_analysis_port是一个参数化的类，其参数就是这个analysis_port需要传递的数据的类型,在本节中是my_transaction。到此,在my_monitor中需要为transaction通信准备的工作已经全部完成。<br>UVM的transaction级别通信的数据接收方式也有多种,其中一种就是使用uvm_blocking_get_port。该接收端已经在 my_monitor 中定义好了。可以往前去看my_monitor的代码。<br>在 my_monitor 和 my_model 中定义并实现了各自的端口之后，通信的功能并没有实现,还需要在 my_env 中使用 fifo 将两个端口联系在一起。下面是my_env 中的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_env</span> <span class="keyword">extends</span> <span class="title class_">uvm_env</span>;</span><br><span class="line">   uvm_tlm_analysis_fifo #(my_transaction) agt_mdl_fifo;</span><br><span class="line">...</span><br><span class="line">   virtual function <span class="keyword">void</span> <span class="title function_">build_phase</span><span class="params">(uvm_phase phase)</span>;</span><br><span class="line">   ...</span><br><span class="line">      agt_mdl_fifo = <span class="keyword">new</span>(<span class="string">&quot;agt_mdl_fifo&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">   endfunction</span><br><span class="line">...</span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line">function <span class="keyword">void</span> my_env::connect_phase(uvm_phase phase);</span><br><span class="line">   <span class="built_in">super</span>.connect_phase(phase);</span><br><span class="line">   i_agt.ap.connect(agt_mdl_fifo.analysis_export);</span><br><span class="line">   mdl.port.connect(agt_mdl_fifo.blocking_get_export);</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">`endif</span><br><span class="line">```java</span><br><span class="line">fifo的类型是uvm_tlm_analysis_fifo，其参数是存储在其中的transaction的类型。</span><br><span class="line">&gt;这里引入了connect_phase。它的执行顺序并不是从树根到树叶,而是从树叶到树根——先执行driver和  monitor的connect_phase,再执行agent的connect_phase,最后执行env的connect_phase。</span><br><span class="line"></span><br><span class="line">但是该连接是与i_agt进行连接，怎么打通i_agt与my_monitor之间的通道呢？就是使用指针的方式。i_agt中的代码如下：</span><br><span class="line">```java</span><br><span class="line">uvm_analysis_port #(my_transaction)  ap;</span><br><span class="line">function <span class="keyword">void</span> my_agent::connect_phase(uvm_phase phase);</span><br><span class="line">   <span class="built_in">super</span>.connect_phase(phase);</span><br><span class="line">   ap = mon.ap;</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<p>在这个代码里面没有实例化，直接将mon中的ap传给i_agt中的ap，就是用指针的形式，在访问i_agt中的ap时等价于访问mon中的ap。</p>
<h1 id="六、scoreboard组件"><a href="#六、scoreboard组件" class="headerlink" title="六、scoreboard组件"></a>六、scoreboard组件</h1><p>该模块的作用就是比较DUT以及镜像模块的输出数值。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">`ifndef MY_SCOREBOARD__SV</span><br><span class="line">`define MY_SCOREBOARD__SV</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_scoreboard</span> <span class="keyword">extends</span> <span class="title class_">uvm_scoreboard</span>;</span><br><span class="line">   my_transaction  expect_queue[$];</span><br><span class="line">   uvm_blocking_get_port #(my_transaction)  exp_port;</span><br><span class="line">   uvm_blocking_get_port #(my_transaction)  act_port;</span><br><span class="line">   `uvm_component_utils(my_scoreboard)</span><br><span class="line"></span><br><span class="line">   extern function <span class="title function_">new</span><span class="params">(string name, uvm_component parent = <span class="literal">null</span>)</span>;</span><br><span class="line">   extern virtual function <span class="keyword">void</span> <span class="title function_">build_phase</span><span class="params">(uvm_phase phase)</span>;</span><br><span class="line">   extern virtual task <span class="title function_">main_phase</span><span class="params">(uvm_phase phase)</span>;</span><br><span class="line">endclass </span><br><span class="line"></span><br><span class="line">function my_scoreboard::<span class="keyword">new</span>(string name, <span class="type">uvm_component</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>);</span><br><span class="line">   <span class="built_in">super</span>.new(name, parent);</span><br><span class="line">endfunction </span><br><span class="line"></span><br><span class="line">function <span class="keyword">void</span> my_scoreboard::build_phase(uvm_phase phase);</span><br><span class="line">   <span class="built_in">super</span>.build_phase(phase);</span><br><span class="line">   exp_port = <span class="keyword">new</span>(<span class="string">&quot;exp_port&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">   act_port = <span class="keyword">new</span>(<span class="string">&quot;act_port&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">endfunction </span><br><span class="line"></span><br><span class="line">task my_scoreboard::main_phase(uvm_phase phase);</span><br><span class="line">   my_transaction  get_expect,  get_actual, tmp_tran;</span><br><span class="line">   bit result;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">super</span>.main_phase(phase);</span><br><span class="line">   fork </span><br><span class="line">      <span class="title function_">while</span> <span class="params">(<span class="number">1</span>)</span> begin</span><br><span class="line">         exp_port.get(get_expect);</span><br><span class="line">         expect_queue.push_back(get_expect);</span><br><span class="line">      end</span><br><span class="line">      <span class="title function_">while</span> <span class="params">(<span class="number">1</span>)</span> begin</span><br><span class="line">         act_port.get(get_actual);</span><br><span class="line">         <span class="keyword">if</span>(expect_queue.size() &gt; <span class="number">0</span>) <span class="type">begin</span></span><br><span class="line">            <span class="variable">tmp_tran</span> <span class="operator">=</span> expect_queue.pop_front();</span><br><span class="line">            result = get_actual.my_compare(tmp_tran);</span><br><span class="line">            <span class="keyword">if</span>(result) begin </span><br><span class="line">               `uvm_info(<span class="string">&quot;my_scoreboard&quot;</span>, <span class="string">&quot;Compare SUCCESSFULLY&quot;</span>, UVM_LOW);</span><br><span class="line">            end</span><br><span class="line">            <span class="keyword">else</span> begin</span><br><span class="line">               `uvm_error(<span class="string">&quot;my_scoreboard&quot;</span>, <span class="string">&quot;Compare FAILED&quot;</span>);</span><br><span class="line">               $display(<span class="string">&quot;the expect pkt is&quot;</span>);</span><br><span class="line">               tmp_tran.my_print();</span><br><span class="line">               $display(<span class="string">&quot;the actual pkt is&quot;</span>);</span><br><span class="line">               get_actual.my_print();</span><br><span class="line">            end</span><br><span class="line">         end</span><br><span class="line">         <span class="keyword">else</span> begin</span><br><span class="line">            `uvm_error(<span class="string">&quot;my_scoreboard&quot;</span>, <span class="string">&quot;Received from DUT, while Expect Queue is empty&quot;</span>);</span><br><span class="line">            $display(<span class="string">&quot;the unexpected pkt is&quot;</span>);</span><br><span class="line">            get_actual.my_print();</span><br><span class="line">         end </span><br><span class="line">      end</span><br><span class="line">   join</span><br><span class="line">endtask</span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
<p>my_scoreboard需要比较两种数据，前者通过exp_port获取，而后者通过  act_port获取。在main_phase中通过fork建立起了两个进程：</p>
<ul>
<li>一个进程处理exp_port的数据，当收到数据后，把数据放入expect_queue中。</li>
<li>另外一个进程处理act_port的数据，这是DUT的输出数据，当收集到这些数据后，将参考数据从队列里面弹出，并调用my_transaction的my_compare函数。</li>
</ul>
<p>最终的UVM树形图如下所示：</p>
<div align=center>
<img src="https://i-blog.csdnimg.cn/direct/2dfa4430c5194be0a118044882f3b675.png" height=250 >
</div>

<p>my_transaction的my_compare函数很简单，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function bit <span class="title function_">my_compare</span><span class="params">(my_transaction tr)</span>;</span><br><span class="line">   bit result;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(tr == <span class="literal">null</span>)</span><br><span class="line">      `uvm_fatal(<span class="string">&quot;my_transaction&quot;</span>, <span class="string">&quot;tr is null!!!!&quot;</span>)</span><br><span class="line">   result = ((dmac == tr.dmac) &amp;&amp;</span><br><span class="line">             (smac == tr.smac) &amp;&amp;</span><br><span class="line">             (ether_type == tr.ether_type) &amp;&amp;</span><br><span class="line">             (crc == tr.crc));</span><br><span class="line">   <span class="keyword">if</span>(pload.size() != tr.pload.size())</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pload.size(); i++) begin</span><br><span class="line">         <span class="title function_">if</span><span class="params">(pload[i] != tr.pload[i])</span></span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">      end</span><br><span class="line">   <span class="keyword">return</span> result; </span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<p>还有两个端口与外界的连接，在书里表示不在过多赘述，这里我简单说一下：首先有两个连接，一个是o_agt的数据，还有一个是my_model中的镜像数据，两者的输入接口都使用<code>uvm_analysis_port #(my_transaction)  ap;</code>来定义。因此在本组件中<code>uvm_blocking_get_port</code>定义接受，连接代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   uvm_tlm_analysis_fifo #(my_transaction) agt_scb_fifo;</span><br><span class="line">   uvm_tlm_analysis_fifo #(my_transaction) agt_mdl_fifo;</span><br><span class="line">   uvm_tlm_analysis_fifo #(my_transaction) mdl_scb_fifo;</span><br><span class="line"></span><br><span class="line">function <span class="keyword">void</span> my_env::connect_phase(uvm_phase phase);</span><br><span class="line">   <span class="built_in">super</span>.connect_phase(phase);</span><br><span class="line">   i_agt.ap.connect(agt_mdl_fifo.analysis_export);</span><br><span class="line">   mdl.port.connect(agt_mdl_fifo.blocking_get_export);</span><br><span class="line">   mdl.ap.connect(mdl_scb_fifo.analysis_export);</span><br><span class="line">   scb.exp_port.connect(mdl_scb_fifo.blocking_get_export);</span><br><span class="line">   o_agt.ap.connect(agt_scb_fifo.analysis_export);</span><br><span class="line">   scb.act_port.connect(agt_scb_fifo.blocking_get_export); </span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<h1 id="七、field-automation机制"><a href="#七、field-automation机制" class="headerlink" title="七、field_automation机制"></a>七、field_automation机制</h1><p>在my_transaction有三个函数，分别为my_print、my_copy以及my_compare函数。使用UVM中的field_automation机制可以将以上三个函数进行整合，该机制使用uvm_field系列宏实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`uvm_object_utils_begin(my_transaction)</span><br><span class="line">   `uvm_field_int(dmac, UVM_ALL_ON)</span><br><span class="line">   `uvm_field_int(smac, UVM_ALL_ON)</span><br><span class="line">   `uvm_field_int(ether_type, UVM_ALL_ON)</span><br><span class="line">   `uvm_field_array_int(pload, UVM_ALL_ON)</span><br><span class="line">   `uvm_field_int(crc, UVM_ALL_ON)</span><br><span class="line">`uvm_object_utils_end</span><br></pre></td></tr></table></figure>
<p>这里使用uvm_object_utils_begin和uvm_object_utils_end来实现my_transaction的factory注册，在这两个宏中间，使用uvm_field宏注册所有字段。通过这样的操作可以直接调用copy、compare、print等函数，而无需自己定义。<br>引入field_automation机制的另外一大好处是简化driver和monitor。my_driver的drv_one_pkt任务和  my_monitor的collect_one_pkt任务代码很长，其作用主要是将数据通过tran连接到DUT上。使用field_automation机制后，drv_one_pkt任务可以简化为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">task my_driver::drive_one_pkt(my_transaction tr);</span><br><span class="line">   <span class="type">byte</span> unsigned     data_q[];</span><br><span class="line">   <span class="type">int</span>  data_size;</span><br><span class="line">   </span><br><span class="line">   data_size = tr.pack_bytes(data_q) / <span class="number">8</span>; </span><br><span class="line">   `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;begin to drive one pkt&quot;</span>, UVM_LOW);</span><br><span class="line">   repeat(<span class="number">3</span>) @(posedge vif.clk);</span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data_size; i++ ) begin</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">      vif.valid &lt;= <span class="number">1</span><span class="string">&#x27;b1;</span></span><br><span class="line"><span class="string">      vif.data &lt;= data_q[i]; </span></span><br><span class="line"><span class="string">   end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   @(posedge vif.clk);</span></span><br><span class="line"><span class="string">   vif.valid &lt;= 1&#x27;</span>b0;</span><br><span class="line">   `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;end drive one pkt&quot;</span>, UVM_LOW);</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
<p>其中调用pack_bytes将tr中所有的字段变成byte流放入data_q中，减少了代码量。同理，在monitor中的解析也是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">task my_monitor::collect_one_pkt(my_transaction tr);</span><br><span class="line">   <span class="type">byte</span> unsigned data_q[$];</span><br><span class="line">   <span class="type">byte</span> unsigned data_array[];</span><br><span class="line">   logic [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line">   <span class="type">logic</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> data_size;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) begin</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">      <span class="keyword">if</span>(vif.valid) <span class="keyword">break</span>;</span><br><span class="line">   end</span><br><span class="line">   </span><br><span class="line">   `uvm_info(<span class="string">&quot;my_monitor&quot;</span>, <span class="string">&quot;begin to collect one pkt&quot;</span>, UVM_LOW);</span><br><span class="line">   <span class="keyword">while</span>(vif.valid) begin</span><br><span class="line">      data_q.push_back(vif.data);</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">   <span class="type">end</span></span><br><span class="line">   <span class="variable">data_size</span>  <span class="operator">=</span> data_q.size();   </span><br><span class="line">   data_array = <span class="keyword">new</span>[data_size];</span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data_size; i++ ) begin</span><br><span class="line">      data_array[i] = data_q[i]; </span><br><span class="line">   end</span><br><span class="line">   tr.pload = <span class="keyword">new</span>[data_size - <span class="number">18</span>]; <span class="comment">//da sa, e_type, crc</span></span><br><span class="line">   data_size = tr.unpack_bytes(data_array) / <span class="number">8</span>; </span><br><span class="line">   `uvm_info(<span class="string">&quot;my_monitor&quot;</span>, <span class="string">&quot;end collect one pkt&quot;</span>, UVM_LOW);</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
<p>这里使用unpack_bytes函数将data_q中的byte流转换成tr中的各个字段。但是这里值得注意的是，unpack_bytes函数的输入参数必须是一个动态数组，所以需要先把收集到的数据放在data_q中的数据复制到一个动态数组中。&#x3D;&#x3D;由于tr中的pload是一个动态数组,所以需要在调用 unpack_bytes 之前指定其大小,这样unpack_bytes函数才能正常工作（这里看不太懂）&#x3D;&#x3D;。</p>
<h1 id="七、sequence组件"><a href="#七、sequence组件" class="headerlink" title="七、sequence组件"></a>七、sequence组件</h1><p>sequence实际上就是一个产生激励的工具，在之前激励都是由my_dirver产生的，这次变为了sequence。在  一个规范化的UVM验证平台中,driver只负责驱动transaction,而不负责产生transaction。sequence机制有两大组成部分,一是  sequence,二是sequencer。</p>
<h2 id="7-1-sequencer"><a href="#7-1-sequencer" class="headerlink" title="7.1 sequencer"></a>7.1 sequencer</h2><p>下面是sequencer的代码部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_sequencer</span> <span class="keyword">extends</span> <span class="title class_">uvm_sequencer</span> #(my_transaction);</span><br><span class="line">   </span><br><span class="line">   function <span class="title function_">new</span><span class="params">(string name, uvm_component parent)</span>;</span><br><span class="line">      <span class="built_in">super</span>.new(name, parent);</span><br><span class="line">   endfunction </span><br><span class="line">   </span><br><span class="line">   `uvm_component_utils(my_sequencer)</span><br><span class="line">endclass</span><br></pre></td></tr></table></figure>
<p>可以看到，uvm_sequencer是一个参数化的类,其参数是my_transaction，即此sequencer产生的transaction的类型。但是，我们上文中的dirver其实也是参数化的类，应该在定义driver时指明此driver要驱动的transaction的类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_driver</span> <span class="keyword">extends</span> <span class="title class_">uvm_driver</span>#(my_transaction);</span><br></pre></td></tr></table></figure>
<p>这样定义的好处是可以直接使用uvm_driver中的某些预先定义好的成员变量，如uvm_driver中有成员变量req，它的类型就是传递给uvm_driver的参数，在这里就是my_transaction，可以直接使用req：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">task my_driver::main_phase(uvm_phase phase);</span><br><span class="line">   phase.raise_objection(<span class="built_in">this</span>);</span><br><span class="line">   vif.data &lt;= <span class="number">8</span><span class="string">&#x27;b0;</span></span><br><span class="line"><span class="string">   vif.valid &lt;= 1&#x27;</span>b0;</span><br><span class="line">   <span class="keyword">while</span>(!vif.rst_n)</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) <span class="type">begin</span> </span><br><span class="line">      <span class="variable">req</span> <span class="operator">=</span> <span class="keyword">new</span>(<span class="string">&quot;req&quot;</span>);</span><br><span class="line">      <span class="keyword">assert</span>(req.randomize() with &#123;pload.size == <span class="number">200</span>;&#125;);</span><br><span class="line">      drive_one_pkt(req);</span><br><span class="line">   end</span><br><span class="line">   <span class="title function_">repeat</span><span class="params">(<span class="number">5</span>)</span> @(posedge vif.clk);</span><br><span class="line">   phase.drop_objection(<span class="built_in">this</span>);</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
<p>然后将该模块加入agent，得到的图如下所示：</p>
<div align=center>
<img src="https://i-blog.csdnimg.cn/direct/2ab39f73831e4e808ae5b1078371900a.png" height=250 >
</div>

<h2 id="7-2-sequence机制"><a href="#7-2-sequence机制" class="headerlink" title="7.2 sequence机制"></a>7.2 sequence机制</h2><p>下面是前面提到的整个UVM的结构图，可以看见sequence的位置在比较偏的地方。这说明sequence并不是一个company而是一个object。</p>
<div align=center>
<img src="https://i-blog.csdnimg.cn/direct/1c725a18ebd84ac3990ca2f08ca1050d.png" height=250 >
</div>

<p>其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_sequence</span> <span class="keyword">extends</span> <span class="title class_">uvm_sequence</span> #(my_transaction);</span><br><span class="line">   my_transaction m_trans;</span><br><span class="line">   function <span class="title function_">new</span><span class="params">(string name= <span class="string">&quot;my_sequence&quot;</span>)</span>;</span><br><span class="line">      <span class="built_in">super</span>.new(name);</span><br><span class="line">   endfunction</span><br><span class="line">   virtual task <span class="title function_">body</span><span class="params">()</span>;</span><br><span class="line">      repeat (<span class="number">10</span>) begin</span><br><span class="line">         `uvm_do(m_trans)</span><br><span class="line">      end</span><br><span class="line">      #<span class="number">1000</span>;</span><br><span class="line">   endtask</span><br><span class="line">   `uvm_object_utils(my_sequence)</span><br><span class="line">endclass</span><br></pre></td></tr></table></figure>
<p>可以看出，该模块在定义时同样要指定产生的transaction的类型，这里是my_transaction。每一个sequence都有一个body任务，当一个sequence启动之后，会自动执行body中的代码。<br>在上面的例子中，用到了uvm_do，其作用为：</p>
<ul>
<li>创建一个my_transaction的实例m_trans</li>
<li>将其随机化</li>
<li>最终将其送给sequencer</li>
</ul>
<p>下一步就是要将uvm_driver和uvm_sequencer以及uvm_sequencer和uvm_sequencer连接起来。<br>在uvm_driver中有成员变量seq_item_port，而在uvm_sequencer中有成员变量seq_item_export，这两者之间可以建立一个“通道”，通道中传递的transaction类型就是定义my_sequencer和my_driver时指定的transaction类型。因此在my_agent中,  使用connect函数把两者联系在一起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function <span class="keyword">void</span> my_agent::connect_phase(uvm_phase phase);</span><br><span class="line">   <span class="built_in">super</span>.connect_phase(phase);</span><br><span class="line">   <span class="keyword">if</span> (is_active == UVM_ACTIVE) begin</span><br><span class="line">      drv.seq_item_port.connect(sqr.seq_item_export);</span><br><span class="line">   <span class="type">end</span></span><br><span class="line">   <span class="variable">ap</span> <span class="operator">=</span> mon.ap;</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<p>链接之后，dirver就可以向sequencer申请。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task my_driver::main_phase(uvm_phase phase);</span><br><span class="line">   vif.data &lt;= <span class="number">8</span><span class="string">&#x27;b0;</span></span><br><span class="line"><span class="string">   vif.valid &lt;= 1&#x27;</span>b0;</span><br><span class="line">   <span class="keyword">while</span>(!vif.rst_n)</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) begin</span><br><span class="line">      seq_item_port.get_next_item(req);</span><br><span class="line">      drive_one_pkt(req);</span><br><span class="line">      seq_item_port.item_done();</span><br><span class="line">   end</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
<p>在如上的代码中，通过get_next_item任务来得到一个新的req,并且驱动它,驱动完成后调用item_done通知sequencer。这里为什么会有一个item_done呢，其主要作用就是让sequencer知道dirver已经接收到了这个req，形成一个类似于握手的机制。<br>uvm_do宏产生了一个transaction并交给sequencer，driver取走这个transaction后，uvm_do并不会立刻返回执行下一次的uvm_do宏，而是等待在那里，直到driver返回item_done信号。此时，uvm_do宏才算是执行完毕，返回后开始执行下一个uvm_do，并产生新的transaction。</p>
<p>然后就是最后一个问题就是将uvm_sequencer和uvm_sequencer连接起来，可以直接在UVM的根部进行定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task my_env::main_phase(uvm_phase phase);</span><br><span class="line">   my_sequence seq;</span><br><span class="line">   phase.raise_objection(<span class="built_in">this</span>);</span><br><span class="line">   seq = my_sequence::type_id::create(<span class="string">&quot;seq&quot;</span>);</span><br><span class="line">   seq.start(i_agt.sqr); </span><br><span class="line">   phase.drop_objection(<span class="built_in">this</span>);</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
<p>首先创建一个my_sequence的实例seq，之后调用start任务。start任务的参数是一个sequencer指针。<br>当然其实还有另一种方法来让dirver获得tran，就是使用try_next_item函数，上文中的get_next_item是阻塞的，而try_next_item则是非阻塞的，这样大大提高了代码的灵活性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">task my_driver::main_phase(uvm_phase phase);</span><br><span class="line">	 vif.data &lt;= <span class="number">8</span><span class="string">&#x27;b0; </span></span><br><span class="line"><span class="string">	 vif.valid &lt;= 1&#x27;</span>b0; </span><br><span class="line">	 <span class="keyword">while</span>(!vif.rst_n) </span><br><span class="line">		 @(posedge vif.clk); </span><br><span class="line"> 	<span class="keyword">while</span>(<span class="number">1</span>)  begin </span><br><span class="line"> 		seq_item_port.try_next_item(req);</span><br><span class="line"> 		 <span class="keyword">if</span>(req == <span class="literal">null</span>) </span><br><span class="line">  			@(posedge vif.clk); </span><br><span class="line">  		<span class="keyword">else</span> begin </span><br><span class="line"> 			 <span class="title function_">drive_one_pkt</span><span class="params">(req)</span>; </span><br><span class="line"> 		 seq_item_port.item_done();</span><br><span class="line">  	 end </span><br><span class="line">   end</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
<h2 id="7-3-default-sequence机制"><a href="#7-3-default-sequence机制" class="headerlink" title="7.3 default_sequence机制"></a>7.3 default_sequence机制</h2><p>在刚才，sequence是在my_env的main_phase中手工启动的，但是在实际应用中,  使用最多的还是通过default_sequence的方式启动sequence。default_sequence的启动方式很简单，只需要在任意地方加入如下代码（以my_env举例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uvm_config_db#(uvm_object_wrapper)::set(<span class="built_in">this</span>,</span><br><span class="line">                                        <span class="string">&quot;i_agt.sqr.main_phase&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;default_sequence&quot;</span>,</span><br><span class="line">                                         my_sequence::type_id::get());</span><br></pre></td></tr></table></figure>
<p>该代码同样使用了uvm_config_db，但是这里是在类里面调用的，第二个参数是相对于第一个参数的相对路径，由于上述代码是在my_env中，所以第二个参数中就不需  要uvm_test_top了。在top_tb中设置virtual interface时,由于top_tb不是一个类，无法使用this指针，所以设置set的第一个参数为null，并且第二个参数使用绝对路径uvm_test_top.xxx。<br>在第二个路径参数中，出现了main_phase。这是因为该代码是在这个位置的main_phase启动的。<br>至于set的第三个和第四个参数，书上说记住就行。<br>还有一个问题就是，在上一节启动sequence前后，分别提起和撤销objection,这里也需要加上这两个操作。sequencer在启动default_sequence时，会自动将自己传给sequence的starting_phase，因此可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">virtual task <span class="title function_">body</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">if</span>(starting_phase != <span class="literal">null</span>) </span><br><span class="line">      starting_phase.raise_objection(<span class="built_in">this</span>);</span><br><span class="line">   repeat (<span class="number">10</span>) begin</span><br><span class="line">      `uvm_do(m_trans)</span><br><span class="line">   end</span><br><span class="line">   #<span class="number">1000</span>;</span><br><span class="line">   <span class="keyword">if</span>(starting_phase != <span class="literal">null</span>) </span><br><span class="line">      starting_phase.drop_objection(<span class="built_in">this</span>);</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
<p>ok，结束。</p>
<h1 id="八、bast-test组件"><a href="#八、bast-test组件" class="headerlink" title="八、bast_test组件"></a>八、bast_test组件</h1><p>没想到吧，其实uvm的树根不是env，而是这个东西。该模块的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base_test</span> <span class="keyword">extends</span> <span class="title class_">uvm_test</span>;</span><br><span class="line"></span><br><span class="line">   my_env         env;</span><br><span class="line">   </span><br><span class="line">   function <span class="title function_">new</span><span class="params">(string name = <span class="string">&quot;base_test&quot;</span>, uvm_component parent = <span class="literal">null</span>)</span>;</span><br><span class="line">      <span class="built_in">super</span>.new(name,parent);</span><br><span class="line">   endfunction</span><br><span class="line">   </span><br><span class="line">   extern virtual function <span class="keyword">void</span> <span class="title function_">build_phase</span><span class="params">(uvm_phase phase)</span>;</span><br><span class="line">   extern virtual function <span class="keyword">void</span> <span class="title function_">report_phase</span><span class="params">(uvm_phase phase)</span>;</span><br><span class="line">   `uvm_component_utils(base_test)</span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function <span class="keyword">void</span> base_test::build_phase(uvm_phase phase);</span><br><span class="line">   <span class="built_in">super</span>.build_phase(phase);</span><br><span class="line">   env  =  my_env::type_id::create(<span class="string">&quot;env&quot;</span>, <span class="built_in">this</span>); </span><br><span class="line">   uvm_config_db#(uvm_object_wrapper)::set(<span class="built_in">this</span>,</span><br><span class="line">                                           <span class="string">&quot;env.i_agt.sqr.main_phase&quot;</span>,</span><br><span class="line">                                           <span class="string">&quot;default_sequence&quot;</span>,</span><br><span class="line">                                            my_sequence::type_id::get());</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">function <span class="keyword">void</span> base_test::report_phase(uvm_phase phase);</span><br><span class="line">   uvm_report_server server;</span><br><span class="line">   <span class="type">int</span> err_num;</span><br><span class="line">   <span class="built_in">super</span>.report_phase(phase);</span><br><span class="line"></span><br><span class="line">   server = get_report_server();</span><br><span class="line">   err_num = server.get_severity_count(UVM_ERROR);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (err_num != <span class="number">0</span>) begin</span><br><span class="line">      $display(<span class="string">&quot;TEST CASE FAILED&quot;</span>);</span><br><span class="line">   end</span><br><span class="line">   <span class="keyword">else</span> begin</span><br><span class="line">      $display(<span class="string">&quot;TEST CASE PASSED&quot;</span>);</span><br><span class="line">   end</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<p>代码很常规，但需要注意的是，这里设置了default_sequence，其他地方就不需要再设置了。<br>上面的代码中出现了report_phase，在report_phase中根据UVM_ERROR的数量来打印不同的信息，其在main_phase结束之后执行。<br>除了上述操作外，还通常在base_test中做如下事情：</p>
<ul>
<li>设置整个验证平台的超时退出时间;</li>
<li>通过config_db设置验证平台中某些参数的值。</li>
</ul>
<p>最终得到的树形结构如下所示：</p>
<div align=center>
<img src="https://i-blog.csdnimg.cn/direct/3f0c6de493004bbd9af7eb0ae15fa890.png" height=250 >
</div>

<h1 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h1><p>到现在为止，一个基本的UVM结构已经完全构建完毕了，后面我会继续为大家分享uvm的相关知识以及项目。谢谢大家支持！！！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.elemenx-king.xyz">Elemen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.elemenx-king.xyz/2025/04/16/675312ec1441/">https://www.elemenx-king.xyz/2025/04/16/675312ec1441/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.elemenx-king.xyz" target="_blank">ElemenX-king</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/UVM/">UVM</a></div><div class="post-share"><div class="addtoany"><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_button_wechat"></a><a class="a2a_button_sina_weibo"></a><a class="a2a_button_email"></a><a class="a2a_button_copy_link"></a><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a></div></div><script async="async" src="https://static.addtoany.com/menu/page.js"></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/04/16/e224389c0e0d/" title="【UVM学习笔记】更加灵活的UVM—通信"><img class="cover" src="/img/cover3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">【UVM学习笔记】更加灵活的UVM—通信</div></div><div class="info-2"><div class="info-item-1">   一、TLM是什么？TLM是Transaction Level Modeling(事务级建模)的缩写。所谓transaction...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/16/e224389c0e0d/" title="【UVM学习笔记】更加灵活的UVM—通信"><img class="cover" src="/img/cover3.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-16</div><div class="info-item-2">【UVM学习笔记】更加灵活的UVM—通信</div></div><div class="info-2"><div class="info-item-1">   一、TLM是什么？TLM是Transaction Level Modeling(事务级建模)的缩写。所谓transaction...</div></div></div></a><a class="pagination-related" href="/2025/04/16/7fdd63537fc6/" title="【UVM学习笔记】UVM中的“类”"><img class="cover" src="/img/cover6.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-16</div><div class="info-item-2">【UVM学习笔记】UVM中的“类”</div></div><div class="info-2"><div class="info-item-1">   一、UVM派生结构在上一篇博客讲述了UVM的结构，大家可以发现所有的结构分为两大类，一个是uvm_component，另一个是uvm_object。uvm_object是UVM中最基本的类,读者能想到的几乎所有的类都继承自uvm_object，包括uvm_component。uvm_component有两大特性是uvm_object所没有的，一是通过在new的时候指定parent参数来形成一种树形的组织结构，二是有phase的自动执行特点。下面是整个UVM类的派生图：     1.1...</div></div></div></a><a class="pagination-related" href="/2025/04/16/130da575206a/" title="【UVM学习笔记】UVM验证平台的运行—Phase以及objection"><img class="cover" src="/img/cover5.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-16</div><div class="info-item-2">【UVM学习笔记】UVM验证平台的运行—Phase以及objection</div></div><div class="info-2"><div class="info-item-1">   一、phase机制1.1 task phase与function phaseUVM中的phase，按照其是否消耗仿真时间的特性，可以分成两大类,一类是function phase，如build_phase、connect_phase等，这些phase都不耗费仿真时间，通过函数来实现；另外一类是task phase，如run_phase等，它们耗费仿真时间，通过任务来实现。灰色背景所示的是task phase，其他为function phase。     值得注意的是，task...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/black_cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Elemen</div><div class="author-info-description">电子科技大学研究生</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ElemenX-king"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/ElemenX-king" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:wangximeng2636@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://www.douyin.com/user/MS4wLjABAAAA6ZvET1XSmd1dE9hyqdFF7H0sQ9tplLmwz45ZdGBnaB8?from_tab_name=main&amp;showTab=post" target="_blank" title="tiktok"><i class="fab fa-tiktok"></i></a><a class="social-icon" href="https://space.bilibili.com/379687140?spm_id_from=333.337.0.0" target="_blank" title="bilibili"><i class="fab fa-bilibili"></i></a><a class="social-icon" href="https://blog.csdn.net/Sn_Mn?ops_request_misc=%7B%22request%5Fid%22%3A%22a6e8416f889cd7542f0fbf83141f50e7%22%2C%22scm%22%3A%2220140713.130064515..%22%7D&amp;request_id=a6e8416f889cd7542f0fbf83141f50e7&amp;biz_id=206&amp;utm_medium=distribute.pc_search_result.none-task-user-null-1-150328636-null-null.nonecase&amp;utm_term=ElemenX-king&amp;spm=1018.2226.3001.4351" target="_blank" title="csdn"><i class="fas fa-c"></i></a><a class="social-icon" href="/wangxxx12124" target="_blank" title="wechat"><i class="fab fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">该网站现在还是测试版本，欢迎大家加我的QQ:3238281044反馈意见😄😄</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Driver%E9%A9%B1%E5%8A%A8%E5%99%A8"><span class="toc-text">一、Driver驱动器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-text">1.1 整体结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A"><span class="toc-text">1.2 详细解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%BF%9D%E6%8A%A4"><span class="toc-text">1.2.1 宏定义保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-text">1.2.2 类定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.2.3 任务实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-factory%E6%9C%BA%E5%88%B6"><span class="toc-text">1.2.4 factory机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-objection%E6%9C%BA%E5%88%B6"><span class="toc-text">1.2.4 objection机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-5-%E5%8A%A0%E5%85%A5virtual-interface"><span class="toc-text">1.2.5 加入virtual interface</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81transaction%E7%BB%84%E4%BB%B6"><span class="toc-text">二、transaction组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81env%E7%BB%84%E4%BB%B6"><span class="toc-text">三、env组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81agent%E7%BB%84%E4%BB%B6"><span class="toc-text">五、agent组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81reference-model%E7%BB%84%E4%BB%B6"><span class="toc-text">五、reference model组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81scoreboard%E7%BB%84%E4%BB%B6"><span class="toc-text">六、scoreboard组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81field-automation%E6%9C%BA%E5%88%B6"><span class="toc-text">七、field_automation机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81sequence%E7%BB%84%E4%BB%B6"><span class="toc-text">七、sequence组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-sequencer"><span class="toc-text">7.1 sequencer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-sequence%E6%9C%BA%E5%88%B6"><span class="toc-text">7.2 sequence机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-default-sequence%E6%9C%BA%E5%88%B6"><span class="toc-text">7.3 default_sequence机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81bast-test%E7%BB%84%E4%BB%B6"><span class="toc-text">八、bast_test组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">九、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/16/130da575206a/" title="【UVM学习笔记】UVM验证平台的运行—Phase以及objection"><img src="/img/cover5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【UVM学习笔记】UVM验证平台的运行—Phase以及objection"/></a><div class="content"><a class="title" href="/2025/04/16/130da575206a/" title="【UVM学习笔记】UVM验证平台的运行—Phase以及objection">【UVM学习笔记】UVM验证平台的运行—Phase以及objection</a><time datetime="2025-04-18T07:15:16.600Z" title="更新于 2025-04-18 15:15:16">2025-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/16/e224389c0e0d/" title="【UVM学习笔记】更加灵活的UVM—通信"><img src="/img/cover3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【UVM学习笔记】更加灵活的UVM—通信"/></a><div class="content"><a class="title" href="/2025/04/16/e224389c0e0d/" title="【UVM学习笔记】更加灵活的UVM—通信">【UVM学习笔记】更加灵活的UVM—通信</a><time datetime="2025-04-18T07:15:16.281Z" title="更新于 2025-04-18 15:15:16">2025-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/16/7fdd63537fc6/" title="【UVM学习笔记】UVM中的“类”"><img src="/img/cover6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【UVM学习笔记】UVM中的“类”"/></a><div class="content"><a class="title" href="/2025/04/16/7fdd63537fc6/" title="【UVM学习笔记】UVM中的“类”">【UVM学习笔记】UVM中的“类”</a><time datetime="2025-04-18T07:15:15.840Z" title="更新于 2025-04-18 15:15:15">2025-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/16/675312ec1441/" title="【UVM学习笔记】UVM基础—一文告诉你UVM的组成部分"><img src="/img/cover2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【UVM学习笔记】UVM基础—一文告诉你UVM的组成部分"/></a><div class="content"><a class="title" href="/2025/04/16/675312ec1441/" title="【UVM学习笔记】UVM基础—一文告诉你UVM的组成部分">【UVM学习笔记】UVM基础—一文告诉你UVM的组成部分</a><time datetime="2025-04-18T07:15:14.922Z" title="更新于 2025-04-18 15:15:14">2025-04-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By Elemen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'ElemenX-king/giscus_demo',
      'data-repo-id': 'R_kgDOOZ_kdw',
      'data-category-id': 'DIC_kwDOOZ_kd84CpHn9',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>