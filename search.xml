<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/04/13/demo/"/>
      <url>/2025/04/13/demo/</url>
      
        <content type="html"><![CDATA[<h1 id="在UVM设计过程中遇到的问题"><a href="#在UVM设计过程中遇到的问题" class="headerlink" title="在UVM设计过程中遇到的问题"></a>在UVM设计过程中遇到的问题</h1><h2 id="Q1-uvm-driver后面的-my-transaction-实际意义是什么"><a href="#Q1-uvm-driver后面的-my-transaction-实际意义是什么" class="headerlink" title="Q1 uvm_driver后面的#(my_transaction)实际意义是什么"></a>Q1 <code>uvm_driver后面的#(my_transaction)实际意义是什么</code></h2><p><code>my_transaction</code> 是你自定义的事务类型，它通常是一个 UVM 中的 <code>uvm_sequence_item</code> 类型。通过将 <code>my_transaction</code> 作为模板参数传递给 <code>uvm_driver</code>，你告诉 UVM 系统，<code>my_driver</code> 会操作类型为 <code>my_transaction</code> 的对象。</p><h2 id="Q2-virtual-是什么意思"><a href="#Q2-virtual-是什么意思" class="headerlink" title="Q2 virtual 是什么意思"></a>Q2 virtual 是什么意思</h2><p><code>virtual</code> 关键字表明该接口 <code>vif</code> 是虚拟的，可以在继承类中<strong>重写</strong>或<strong>动态绑定</strong>。这意味着接口 <code>vif</code> 可以在不同的上下文中指向不同的对象。它让你可以在继承体系中选择特定的接口实现，而不仅仅是使用一个静态的接口对象。</p><p>下面是几点注意的事项</p><ul><li><p>类的成员方法可以加修饰词<code>virtual</code>（虚方法）</p></li><li><p>虚方法是一种基本的多态结构</p></li><li><p>一个虚方法可以覆盖基类的同名方法</p></li><li><p>在父类和子类中声明虚方法，其方法名、参数名、参数方向都应该保持一致</p></li><li><p>在调用虚方法时，它将调用句柄指向对象的方法，而不受句柄类型的影响</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class BasePacket;</span><br><span class="line">  int A = 1;</span><br><span class="line">  int B = 2;</span><br><span class="line">  </span><br><span class="line">  function void printA;</span><br><span class="line">    $display(&quot;BasePacket::A is %d&quot;, A);</span><br><span class="line">  endfunction</span><br><span class="line">  </span><br><span class="line">  virtual function void printB;</span><br><span class="line">    $display(&quot;BasePacket::B is %d&quot;, B);</span><br><span class="line">  endfunction</span><br><span class="line"></span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line">class My_Packet extends BasePacket;</span><br><span class="line">  int A = 3;</span><br><span class="line">  int B = 4;</span><br><span class="line"></span><br><span class="line">  function void printA;</span><br><span class="line">    $display(&quot;My_Packet::A is %d&quot;, A);</span><br><span class="line">  endfunction</span><br><span class="line"></span><br><span class="line">  virtual function void printB;</span><br><span class="line">    $display(&quot;My_Packet::B is %d&quot;, B);  </span><br><span class="line">  endfunction</span><br><span class="line"></span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line">module tb;</span><br><span class="line">  BasePacket P1 = new();</span><br><span class="line">  My_Packet P2 = new();</span><br><span class="line"></span><br><span class="line">  initial begin</span><br><span class="line">    P1.printA;  // A is 1</span><br><span class="line">    P1.printB;  // B is 2</span><br><span class="line">    P1 = P2;    // 子类句柄赋值给父类，父类句柄指向子类的对象</span><br><span class="line">    P1.printA;  // A is 1</span><br><span class="line">    P1.printB;  // B is 4</span><br><span class="line">    P2.printA;  // A is 3</span><br><span class="line">    P2.printB;  // B is 4</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h2 id="Q3-new函数的意义是什么"><a href="#Q3-new函数的意义是什么" class="headerlink" title="Q3 new函数的意义是什么"></a>Q3 new函数的意义是什么</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function new(string name = &quot;uart_driver&quot;, uvm_component parent = null);</span><br><span class="line">    super.new(name, parent);</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure><p><code>new</code> 关键字通常用于创建对象的实例。在 UVM（Universal Verification Methodology）中，<code>new</code> 函数是类的构造函数，它用于初始化类的对象。</p><p><code>name</code>: 这是一个字符串参数，默认为 <code>&quot;uart_driver&quot;</code>，表示该组件的名称。</p><p><code>parent</code>: 这是一个 <code>uvm_component</code> 类型的参数，默认为 <code>null</code>，表示该组件的父组件。<code>uvm_component</code> 是 UVM 中所有组件的基类，父组件通常是该组件所属的父级 UVM 构件。</p><p><code>super</code> 是 SystemVerilog 中的关键字，用于调用父类的方法或构造函数。这里，它用于调用父类的构造函数。</p><blockquote><p>通过<code>super</code> 关键字，可以实现自下到上的调用</p></blockquote><h2 id="Q4-代码里面的“-”是什么意思"><a href="#Q4-代码里面的“-”是什么意思" class="headerlink" title="Q4 代码里面的“::”是什么意思"></a>Q4 代码里面的“::”是什么意思</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function void uart_driver::build_phase(uvm_phase phase);</span><br></pre></td></tr></table></figure><p>::表示的是后者属于前者的函数或者是任务。</p><h2 id="Q5-uvm中的constraint是什么"><a href="#Q5-uvm中的constraint是什么" class="headerlink" title="Q5 uvm中的constraint是什么"></a>Q5 uvm中的constraint是什么</h2><p>在 UVM（Universal Verification Methodology）中，<strong>constraint（约束）</strong> 是用于控制或限制对象随机化过程中某些变量或字段值的规则。它是 SystemVerilog 的一种特性，通常用于在生成随机数据时确保生成的数据满足一定的条件。</p><p>验证对象（例如 <code>uvm_sequence_item</code>）经常会定义一些字段，这些字段通常使用 <code>rand</code> 或 <code>randc</code> 修饰符进行随机化。为了确保这些字段在生成时满足一些特定条件，可以通过约束来控制它们的随机值。</p><blockquote><p>因此该语句需要与rand进行搭配，实现对随机数的约束</p></blockquote><h2 id="Q6-什么是Clocking-Blocks组件"><a href="#Q6-什么是Clocking-Blocks组件" class="headerlink" title="Q6 什么是Clocking Blocks组件"></a>Q6 什么是<strong>Clocking Blocks组件</strong></h2><p><strong>Clocking blocks</strong> 是用于控制和同步信号的时序。在 <code>clocking block</code> 中，可以指定信号的同步方式以及输入和输出的延迟时间。它们通常与时钟信号一起使用，用于在设计的验证中统一信号的采样和驱动时机。</p><p>如下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 时钟同步，用于模拟真实的时钟</span><br><span class="line">  clocking driver_cb @(posedge PCLK);</span><br><span class="line">    default input #1 output #1;</span><br><span class="line">  output  RX;</span><br><span class="line">  endclocking</span><br><span class="line">    </span><br><span class="line">  clocking monitor_cb @(posedge PCLK);</span><br><span class="line">    default input #1 output #1;</span><br><span class="line">  input Tx;  </span><br><span class="line">  endclocking</span><br></pre></td></tr></table></figure><ul><li><p><strong>driver_cb</strong>：这是一个 <strong>clocking block</strong>，在 <code>posedge PCLK</code>（PCLK 上升沿）时进行同步，表示时序约束是基于 <code>PCLK</code> 信号的上升沿。</p></li><li><p><strong>default input #1 output #1</strong>：这行定义了所有信号的默认时序约束，即：</p><ul><li><p><strong>input #1</strong>：所有的输入信号将延迟 1 个时钟周期。</p></li><li><p><strong>output #1</strong>：所有的输出信号也会延迟 1 个时钟周期。</p></li></ul></li><li><p><strong>output RX</strong>：这里定义了一个输出信号 <code>RX</code>，并且它将在时钟上升沿同步后被驱动。</p></li></ul><p>相当于RX信号变成了收到特定约束的driver_cb，TX信号变成了driver_cb 。后面再使用<code>modport</code> 定义了每一个接口的输出方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modport DRIVER (clocking driver_cb , input PCLK, PRESETn); </span><br><span class="line">modport MONITOR (clocking monitor_cb , input PCLK, PRESETn);</span><br></pre></td></tr></table></figure><h2 id="Q7-uvm-analysis-port是什么"><a href="#Q7-uvm-analysis-port是什么" class="headerlink" title="Q7 uvm_analysis_port是什么"></a>Q7 uvm_analysis_port是什么</h2><p>uvm_analysis_port 用于组件之间的数据分析传输。它通常由提供数据的组件（如 Monitor）和接收数据的组件（如 Scoreboard 或 Analysis Component）之间使用。它是 UVM 提供的标准端口，用于异步传输事件或事务。</p><ul><li><p>Monitor 使用 <code>uvm_analysis_port</code> 将捕获的事务发送给其他验证组件（例如 Scoreboard 或 Coverage）进行进一步的检查或分析。</p></li><li><p>Scoreboard 或 Coverage Collector 等组件会使用 <code>uvm_analysis_export</code> 来接收数据并进行验证或覆盖分析。</p></li></ul><h2 id="Q8-posedge-vifuart-PCLK-iff-vifuart-PRESETn-中的iff是什么"><a href="#Q8-posedge-vifuart-PCLK-iff-vifuart-PRESETn-中的iff是什么" class="headerlink" title="Q8 @(posedge vifuart.PCLK iff (vifuart.PRESETn))中的iff是什么"></a>Q8 @(posedge vifuart.PCLK iff (vifuart.PRESETn))中的iff是什么</h2><p><code>iff</code> 是 SystemVerilog 中的条件控制符，表示 <strong>“如果”</strong>，也就是在特定条件满足时，才会触发该事件。<code>vifuart.PRESETn</code> 是条件信号，它代表着一个复位信号的反向（<code>n</code> 通常表示 <strong>负逻辑</strong>，即 <code>0</code> 表示复位，<code>1</code> 表示正常工作）。</p><p>只有当 <code>vifuart.PRESETn</code> 为高电平（即复位解除）时，才会触发事件。</p><h2 id="Q9-uvm-analysis-imp-decl-宏的使用"><a href="#Q9-uvm-analysis-imp-decl-宏的使用" class="headerlink" title="Q9 `uvm_analysis_imp_decl()宏的使用"></a>Q9 <strong>`uvm_analysis_imp_decl()宏的使用</strong></h2><p>当出现analysis_imp所在的component需要接收多路数据的情况时，但write只有一个，那么该如何定义write呢？这时就用到了宏uvm_analysis_imp_decl。示例代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">`uvm_analysis_imp_decl(_monitor)</span><br><span class="line">`uvm_analysis_imp_decl(_model)</span><br><span class="line">class my_scoreboard extends uvm_scoreboard;</span><br><span class="line">my_transaction tr;</span><br><span class="line"></span><br><span class="line">uvm_analysis_imp_monitor#(my_transaction ,my_scoreboard) monitor_imp;</span><br><span class="line">uvm_analysis_imp_model#(my_transaction ,my_scoreboard) model_imp;</span><br><span class="line"></span><br><span class="line">extern function void write_monitor(my_transaction tr);</span><br><span class="line">extern function void write_model(my_transaction tr);</span><br><span class="line">        extern function void build_phase(uvm_phase phase);</span><br><span class="line">endclass</span><br><span class="line">function void my_scoreboard::write_monitor(my_transaction tr);</span><br><span class="line"> </span><br><span class="line">endfunction</span><br><span class="line">function void my_scoreboard::write_model(my_transaction tr);</span><br><span class="line"> </span><br><span class="line">endfunction</span><br><span class="line">function my_scoreboard::void build_phase(uvm_phase phase);</span><br><span class="line">    super.build_phase(phase);</span><br><span class="line">    monitor_imp = new(&quot;monitor_imp&quot;, this);</span><br><span class="line">    model_imp   = new(&quot;model_imp&quot;, this);</span><br><span class="line">endfunction: build_phase</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
