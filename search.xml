<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2025/04/13/demo/</url>
    <content><![CDATA[在UVM设计过程中遇到的问题Q1 uvm_driver后面的#(my_transaction)实际意义是什么my_transaction 是你自定义的事务类型，它通常是一个 UVM 中的 uvm_sequence_item 类型。通过将 my_transaction 作为模板参数传递给 uvm_driver，你告诉 UVM 系统，my_driver 会操作类型为 my_transaction 的对象。
Q2 virtual 是什么意思virtual 关键字表明该接口 vif 是虚拟的，可以在继承类中重写或动态绑定。这意味着接口 vif 可以在不同的上下文中指向不同的对象。它让你可以在继承体系中选择特定的接口实现，而不仅仅是使用一个静态的接口对象。
下面是几点注意的事项

类的成员方法可以加修饰词virtual（虚方法）

虚方法是一种基本的多态结构

一个虚方法可以覆盖基类的同名方法

在父类和子类中声明虚方法，其方法名、参数名、参数方向都应该保持一致

在调用虚方法时，它将调用句柄指向对象的方法，而不受句柄类型的影响


class BasePacket;  int A = 1;  int B = 2;    function void printA;    $display(&quot;BasePacket::A is %d&quot;, A);  endfunction    virtual function void printB;    $display(&quot;BasePacket::B is %d&quot;, B);  endfunctionendclassclass My_Packet extends BasePacket;  int A = 3;  int B = 4;  function void printA;    $display(&quot;My_Packet::A is %d&quot;, A);  endfunction  virtual function void printB;    $display(&quot;My_Packet::B is %d&quot;, B);    endfunctionendclassmodule tb;  BasePacket P1 = new();  My_Packet P2 = new();  initial begin    P1.printA;  // A is 1    P1.printB;  // B is 2    P1 = P2;    // 子类句柄赋值给父类，父类句柄指向子类的对象    P1.printA;  // A is 1    P1.printB;  // B is 4    P2.printA;  // A is 3    P2.printB;  // B is 4  endendmodule

Q3 new函数的意义是什么function new(string name = &quot;uart_driver&quot;, uvm_component parent = null);    super.new(name, parent);endfunction

new 关键字通常用于创建对象的实例。在 UVM（Universal Verification Methodology）中，new 函数是类的构造函数，它用于初始化类的对象。
name: 这是一个字符串参数，默认为 &quot;uart_driver&quot;，表示该组件的名称。
parent: 这是一个 uvm_component 类型的参数，默认为 null，表示该组件的父组件。uvm_component 是 UVM 中所有组件的基类，父组件通常是该组件所属的父级 UVM 构件。
super 是 SystemVerilog 中的关键字，用于调用父类的方法或构造函数。这里，它用于调用父类的构造函数。

通过super 关键字，可以实现自下到上的调用

Q4 代码里面的“::”是什么意思function void uart_driver::build_phase(uvm_phase phase);

::表示的是后者属于前者的函数或者是任务。
Q5 uvm中的constraint是什么在 UVM（Universal Verification Methodology）中，constraint（约束） 是用于控制或限制对象随机化过程中某些变量或字段值的规则。它是 SystemVerilog 的一种特性，通常用于在生成随机数据时确保生成的数据满足一定的条件。
验证对象（例如 uvm_sequence_item）经常会定义一些字段，这些字段通常使用 rand 或 randc 修饰符进行随机化。为了确保这些字段在生成时满足一些特定条件，可以通过约束来控制它们的随机值。

因此该语句需要与rand进行搭配，实现对随机数的约束

Q6 什么是Clocking Blocks组件Clocking blocks 是用于控制和同步信号的时序。在 clocking block 中，可以指定信号的同步方式以及输入和输出的延迟时间。它们通常与时钟信号一起使用，用于在设计的验证中统一信号的采样和驱动时机。
如下面的代码：
// 时钟同步，用于模拟真实的时钟  clocking driver_cb @(posedge PCLK);    default input #1 output #1;	  output  RX;  endclocking      clocking monitor_cb @(posedge PCLK);    default input #1 output #1;  input Tx;    endclocking


driver_cb：这是一个 clocking block，在 posedge PCLK（PCLK 上升沿）时进行同步，表示时序约束是基于 PCLK 信号的上升沿。

default input #1 output #1：这行定义了所有信号的默认时序约束，即：

input #1：所有的输入信号将延迟 1 个时钟周期。

output #1：所有的输出信号也会延迟 1 个时钟周期。



output RX：这里定义了一个输出信号 RX，并且它将在时钟上升沿同步后被驱动。


相当于RX信号变成了收到特定约束的driver_cb，TX信号变成了driver_cb 。后面再使用modport 定义了每一个接口的输出方式：
modport DRIVER (clocking driver_cb , input PCLK, PRESETn); modport MONITOR (clocking monitor_cb , input PCLK, PRESETn);

Q7 uvm_analysis_port是什么uvm_analysis_port 用于组件之间的数据分析传输。它通常由提供数据的组件（如 Monitor）和接收数据的组件（如 Scoreboard 或 Analysis Component）之间使用。它是 UVM 提供的标准端口，用于异步传输事件或事务。

Monitor 使用 uvm_analysis_port 将捕获的事务发送给其他验证组件（例如 Scoreboard 或 Coverage）进行进一步的检查或分析。

Scoreboard 或 Coverage Collector 等组件会使用 uvm_analysis_export 来接收数据并进行验证或覆盖分析。


Q8 @(posedge vifuart.PCLK iff (vifuart.PRESETn))中的iff是什么iff 是 SystemVerilog 中的条件控制符，表示 “如果”，也就是在特定条件满足时，才会触发该事件。vifuart.PRESETn 是条件信号，它代表着一个复位信号的反向（n 通常表示 负逻辑，即 0 表示复位，1 表示正常工作）。
只有当 vifuart.PRESETn 为高电平（即复位解除）时，才会触发事件。
Q9 `uvm_analysis_imp_decl()宏的使用当出现analysis_imp所在的component需要接收多路数据的情况时，但write只有一个，那么该如何定义write呢？这时就用到了宏uvm_analysis_imp_decl。示例代码如下所示：
`uvm_analysis_imp_decl(_monitor)`uvm_analysis_imp_decl(_model)class my_scoreboard extends uvm_scoreboard;		my_transaction tr;				uvm_analysis_imp_monitor#(my_transaction ,my_scoreboard) monitor_imp;		uvm_analysis_imp_model#(my_transaction ,my_scoreboard) model_imp;				extern function void write_monitor(my_transaction tr);		extern function void write_model(my_transaction tr);        extern function void build_phase(uvm_phase phase);endclassfunction void my_scoreboard::write_monitor(my_transaction tr); endfunctionfunction void my_scoreboard::write_model(my_transaction tr); endfunctionfunction my_scoreboard::void build_phase(uvm_phase phase);    super.build_phase(phase);    monitor_imp = new(&quot;monitor_imp&quot;, this);    model_imp   = new(&quot;model_imp&quot;, this);endfunction: build_phase]]></content>
  </entry>
</search>
