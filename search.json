[{"title":"Hello World","url":"/ElemenX-king/ElemenX-king.github.io.git/2025/04/13/demo/","content":"# 在UVM设计过程中遇到的问题\n\n## Q1 `uvm_driver后面的#(my_transaction)实际意义是什么`\n\n`my_transaction` 是你自定义的事务类型，它通常是一个 UVM 中的 `uvm_sequence_item` 类型。通过将 `my_transaction` 作为模板参数传递给 `uvm_driver`，你告诉 UVM 系统，`my_driver` 会操作类型为 `my_transaction` 的对象。\n\n## Q2 virtual 是什么意思\n\n`virtual` 关键字表明该接口 `vif` 是虚拟的，可以在继承类中**重写**或**动态绑定**。这意味着接口 `vif` 可以在不同的上下文中指向不同的对象。它让你可以在继承体系中选择特定的接口实现，而不仅仅是使用一个静态的接口对象。\n\n下面是几点注意的事项\n\n- 类的成员方法可以加修饰词`virtual`（虚方法）\n    \n- 虚方法是一种基本的多态结构\n    \n- 一个虚方法可以覆盖基类的同名方法\n    \n- 在父类和子类中声明虚方法，其方法名、参数名、参数方向都应该保持一致\n    \n- 在调用虚方法时，它将调用句柄指向对象的方法，而不受句柄类型的影响\n    \n\n```java\nclass BasePacket;\n  int A = 1;\n  int B = 2;\n  \n  function void printA;\n    $display(\"BasePacket::A is %d\", A);\n  endfunction\n  \n  virtual function void printB;\n    $display(\"BasePacket::B is %d\", B);\n  endfunction\n\nendclass\n\nclass My_Packet extends BasePacket;\n  int A = 3;\n  int B = 4;\n\n  function void printA;\n    $display(\"My_Packet::A is %d\", A);\n  endfunction\n\n  virtual function void printB;\n    $display(\"My_Packet::B is %d\", B);  \n  endfunction\n\nendclass\n\nmodule tb;\n  BasePacket P1 = new();\n  My_Packet P2 = new();\n\n  initial begin\n    P1.printA;  // A is 1\n    P1.printB;  // B is 2\n    P1 = P2;    // 子类句柄赋值给父类，父类句柄指向子类的对象\n    P1.printA;  // A is 1\n    P1.printB;  // B is 4\n    P2.printA;  // A is 3\n    P2.printB;  // B is 4\n  end\n\nendmodule\n```\n\n## Q3 new函数的意义是什么\n\n```java\nfunction new(string name = \"uart_driver\", uvm_component parent = null);\n    super.new(name, parent);\nendfunction\n```\n\n`new` 关键字通常用于创建对象的实例。在 UVM（Universal Verification Methodology）中，`new` 函数是类的构造函数，它用于初始化类的对象。\n\n`name`: 这是一个字符串参数，默认为 `\"uart_driver\"`，表示该组件的名称。\n\n`parent`: 这是一个 `uvm_component` 类型的参数，默认为 `null`，表示该组件的父组件。`uvm_component` 是 UVM 中所有组件的基类，父组件通常是该组件所属的父级 UVM 构件。\n\n`super` 是 SystemVerilog 中的关键字，用于调用父类的方法或构造函数。这里，它用于调用父类的构造函数。\n\n> 通过`super` 关键字，可以实现自下到上的调用\n\n## Q4 代码里面的“::”是什么意思\n\n```java\nfunction void uart_driver::build_phase(uvm_phase phase);\n```\n\n::表示的是后者属于前者的函数或者是任务。\n\n## Q5 uvm中的constraint是什么\n\n在 UVM（Universal Verification Methodology）中，**constraint（约束）** 是用于控制或限制对象随机化过程中某些变量或字段值的规则。它是 SystemVerilog 的一种特性，通常用于在生成随机数据时确保生成的数据满足一定的条件。\n\n验证对象（例如 `uvm_sequence_item`）经常会定义一些字段，这些字段通常使用 `rand` 或 `randc` 修饰符进行随机化。为了确保这些字段在生成时满足一些特定条件，可以通过约束来控制它们的随机值。\n\n> 因此该语句需要与rand进行搭配，实现对随机数的约束\n\n## Q6 什么是**Clocking Blocks组件**\n\n**Clocking blocks** 是用于控制和同步信号的时序。在 `clocking block` 中，可以指定信号的同步方式以及输入和输出的延迟时间。它们通常与时钟信号一起使用，用于在设计的验证中统一信号的采样和驱动时机。\n\n如下面的代码：\n\n```java\n// 时钟同步，用于模拟真实的时钟\n  clocking driver_cb @(posedge PCLK);\n    default input #1 output #1;\t\n  output  RX;\n  endclocking\n    \n  clocking monitor_cb @(posedge PCLK);\n    default input #1 output #1;\n  input Tx;  \n  endclocking\n```\n\n- **driver_cb**：这是一个 **clocking block**，在 `posedge PCLK`（PCLK 上升沿）时进行同步，表示时序约束是基于 `PCLK` 信号的上升沿。\n    \n- **default input #1 output #1**：这行定义了所有信号的默认时序约束，即：\n    \n    - **input #1**：所有的输入信号将延迟 1 个时钟周期。\n        \n    - **output #1**：所有的输出信号也会延迟 1 个时钟周期。\n        \n- **output RX**：这里定义了一个输出信号 `RX`，并且它将在时钟上升沿同步后被驱动。\n    \n\n相当于RX信号变成了收到特定约束的driver_cb，TX信号变成了driver_cb 。后面再使用`modport` 定义了每一个接口的输出方式：\n\n```java\nmodport DRIVER (clocking driver_cb , input PCLK, PRESETn); \nmodport MONITOR (clocking monitor_cb , input PCLK, PRESETn);\n```\n\n## Q7 uvm_analysis_port是什么\n\nuvm_analysis_port 用于组件之间的数据分析传输。它通常由提供数据的组件（如 Monitor）和接收数据的组件（如 Scoreboard 或 Analysis Component）之间使用。它是 UVM 提供的标准端口，用于异步传输事件或事务。\n\n- Monitor 使用 `uvm_analysis_port` 将捕获的事务发送给其他验证组件（例如 Scoreboard 或 Coverage）进行进一步的检查或分析。\n    \n- Scoreboard 或 Coverage Collector 等组件会使用 `uvm_analysis_export` 来接收数据并进行验证或覆盖分析。\n    \n\n## Q8 @(posedge vifuart.PCLK iff (vifuart.PRESETn))中的iff是什么\n\n`iff` 是 SystemVerilog 中的条件控制符，表示 **\"如果\"**，也就是在特定条件满足时，才会触发该事件。`vifuart.PRESETn` 是条件信号，它代表着一个复位信号的反向（`n` 通常表示 **负逻辑**，即 `0` 表示复位，`1` 表示正常工作）。\n\n只有当 `vifuart.PRESETn` 为高电平（即复位解除）时，才会触发事件。\n\n## Q9 **\\`uvm_analysis_imp_decl()宏的使用**\n\n当出现analysis_imp所在的component需要接收多路数据的情况时，但write只有一个，那么该如何定义write呢？这时就用到了宏uvm_analysis_imp_decl。示例代码如下所示：\n\n```java\n`uvm_analysis_imp_decl(_monitor)\n`uvm_analysis_imp_decl(_model)\nclass my_scoreboard extends uvm_scoreboard;\n\t\tmy_transaction tr;\n\t\t\n\t\tuvm_analysis_imp_monitor#(my_transaction ,my_scoreboard) monitor_imp;\n\t\tuvm_analysis_imp_model#(my_transaction ,my_scoreboard) model_imp;\n\t\t\n\t\textern function void write_monitor(my_transaction tr);\n\t\textern function void write_model(my_transaction tr);\n        extern function void build_phase(uvm_phase phase);\nendclass\nfunction void my_scoreboard::write_monitor(my_transaction tr);\n \nendfunction\nfunction void my_scoreboard::write_model(my_transaction tr);\n \nendfunction\nfunction my_scoreboard::void build_phase(uvm_phase phase);\n    super.build_phase(phase);\n    monitor_imp = new(\"monitor_imp\", this);\n    model_imp   = new(\"model_imp\", this);\nendfunction: build_phase\n```"}]