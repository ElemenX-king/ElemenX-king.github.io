[{"title":"【UVM项目实战】异步fifo—uvm项目结构以及uvm环境搭建","url":"/2025/04/24/d18911f2be8e/","content":"\n{% raw %}\n<meta name=\"referrer\" content=\"no-referrer\"/>\n{% endraw %}\n\n---\n\n# 一、异步FIFO\n## 1.1 异步FIFO的定义\n异步时序设计指的是在设计中有两个或以上的时钟， 且时钟之间是同频不同相或不同频率的关系。而异步时序设计的关键就是把数据或控制信号正确地进行跨时钟域传输。\n一个异步 FIFO 一般由如下部分组成：\n1. Memory, 作为数据的存储器；\n2. 写逻辑部分，主要负责产生写信号和地址；\n3. 读逻辑部分，主要负责产生读信号和地址；\n4. 地址比较部分，主要负责产生 FIFO 空、满的标志。\n\n跟普通的FIFO相比，异步FIFO实际上多了读写地址的跨时钟域同步的逻辑，以及两个时钟域中读写信号的比较逻辑。\n## 1.2 亚稳态\n每一个触发器都有其规定的建立(setup)和保持(hold)时间参数, 在这个时间参数内， 输入信号在时钟的上升沿是不允许发生变的。 如果在信号的建立时间中对其进行采样， 得到的结果将是不可预知的，即亚稳态。\n为了避免亚稳态。采用双锁存器可以改善这一问题：\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/2baa7c0ec4d34b0898632a98a496aeb4.png\" height=200 >\n</div>\n\n>时钟域B两级同步的寄存器跟时钟域A的输出寄存器之间不能有组合逻辑。组合逻辑电路各个输入信号的不一致性以及组合逻辑内部路径的延时时间不一样，运算后的信号存在毛刺。\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/6551b7182ffc4bfe803bac643edf13ae.png\" height=350 >\n</div>\n\n## 1.3 异步FIFO关键技术一\n这里用到了一个很重要的概念“回卷”，通常判断读写的地址是否相同来判断空和满，这里使用回卷技术，在深度为8的fifo中多一位来代表回卷位，当fifo溢出之后，回卷位会被置1，当读时钟和写时钟的回卷位不同而其他位相同时，表示fifo已经满，因为写地址在溢出后的位置，而读时钟在溢出前。\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/a0029cec78fe4ec993238e0739c0064a.png\" height=350 >\n</div>\n\n## 1.3 异步FIFO关键技术二\n将满和将空信号实际上表示更加保守的满和空信号。基本思路是，设定一个间隔值，当读写地址之间的间隔小于或等于该间隔就产生将空或将满信号。\n对于异步FIFO而言，由于同步过来的地址信号都是格雷码表示的，我们不能直接用格雷码去判断上述的这个间隔，所以需要先对接受到的格雷码进行解码变为二进制，再和当前时钟域下的另一个地址进行将满和将空的生成。\n## 1.4 FIFO逻辑图\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/0a4a6e4dbd0341698fd987fc684078a3.png\" height=350 >\n</div>\n\n---\n# 二、UVM结构\n该项目的UVM包括以下几个文件：\nfifo_if.sv\nfifo_case0.sv\nbase_test.sv\ntop_tb.sv\nfifo_driver.sv\nfifo_model.sv\nfifo_transaction.sv\nfifo_in_monitor.sv\nfifo_env.sv\nfifo_scoreboard.sv\nfifo_chk_rst.sv\nfifo_in_sequencer.sv\nfifo_in_agent.sv\nmy_env.sv\nfifo_out_monitor.sv\nfifo_out_agent.sv\n下面是本次UVM的整体框架：\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/3fcbbca3eb824342acaeb8c10e15c992.png\" height=300 >\n</div>\n\n现在对每一个文件进行解释。\n## 2.1 interface\n该文件主要是用于连接DUT的物理信号与UVM的事件信号，起主要是在top_tb中进行定义和连接，然后通过`uvm_config_db`进行定点发送。\n```java\n`ifndef FIFO_IF__SV\n`define FIFO_IF__SV\n\n// 括号里面是时钟信号\ninterface fifo_if(input wclk, input rclk, input wreset_b, input rreset_b);\n    logic write,read;\n\tlogic [31 : 0] wdata;\n\tlogic [31 : 0] rdata;\n    wire  wfull,rempty; // logic\n    /***********时钟约束************/\n    // wdata为inout\n    clocking ckw @(posedge wclk);\n\t\tinput  wfull;\n\t\tinout  write;\n\t\tinout  wdata;\n\tendclocking\n    // wdata为input\n    clocking ckim @(posedge wclk);\n\t\tinput wfull;              \n\t\tinout  write;             \n\t\tinput  wdata;\n\tendclocking\n    // \n    clocking ckom @(posedge rclk);\n\t\tinput  rempty;\n\t\tinout  read;\n\t\tinput  rdata;\n\tendclocking\n    /***********方向约束************/\n    // 普通模式\n    modport DUT(\n\t\tinput write,\n\t\tinput read,\n\t\tinput wdata,\n\t\toutput rdata,\n\t\toutput wfull,\n\t\toutput rempty\n\t);\n    // 读取模式\n    modport DRV(\n\t\tclocking ckw,\n\t\tinput read,\n\t\tinput rdata,\n\t\tinput rempty\n\t);\n    \n    modport OMON(\n\t\tclocking ckom,\n\t\tinput wfull,\n\t\tinput write,\n\t\tinput wdata\n\t);\nendinterface //interfacename\n\n`endif\n```\nclocking主要是定义每个logic信号的方向，同时制定该信号同步的时钟域。括号里信号的作用是控制 clocking 块内的所有信号的同步时序。时钟信号 的上升沿会触发对这些信号的**采样或更新**。\nmodport的作用是定义了一个接口的访问模式，指定了如何访问时钟块 ckw 和接口中的信号。具体来说，它允许从外部访问 read、rdata 和 rempty 信号，并且会在时钟块 ckw 中进行同步。\n## 2.2 transaction\ntransaction主要是用于对信号进行打包操作，本项目只有一个输入data_in，因此只需要生成一个随机数据。同时基于约束并注册（这是基本操作）。\n```java\n`ifndef FIFO_TRANSACTION__SV\n`define FIFO_TRANSACTION__SV\n\nclass fifo_transaction extends uvm_sequence_item;\n    // 产生的随机数据\n    rand bit[31:0] data_in[];\n    \n    // 约束\n\tconstraint data_in_c {\n\t\tsoft data_in.size inside {[1:300]};\n\t}\n    // 将数据加入注册\n\t`uvm_object_utils_begin(fifo_transaction)\n\t\t`uvm_field_array_int(data_in,UVM_ALL_ON)\n\t`uvm_object_utils_end\n    \n    // 构造函数\n\tfunction new(string name = \"fifo_transaction\");\n\t\tsuper.new(name);\n\tendfunction\nendclass\n`endif\n```\n## 2.3 driver\n驱动器是UVM中的核心，代码如下所示：\n```java\n`ifndef FIFO_DRIVER__SV\n`define FIFO_DRIVER__SV\n\nclass fifo_driver extends uvm_driver#(fifo_transaction);\n    virtual fifo_if vif;\n    //define 功能覆盖率 是否达到 空 满 状态\n\t\tcovergroup cov_label;\n\t\t\toption.per_instance = 1;\n\t\t\toption.auto_bin_max = 2;\n\t\t\tcoverpoint vif.wfull;\n\t\t\tcoverpoint vif.rempty;\n\t\tendgroup\n    // 注册\n    `uvm_component_utils(fifo_driver)\n    // 构造函数\n    function new(string name = \"fifo_driver\", uvm_component parent = null);\n       super.new(name, parent);\n       cov_label = new(); // 创建覆盖率\n    endfunction\n\n    // 初始化函数\n    virtual function void build_phase(uvm_phase phase);\n\t\tsuper.build_phase(phase);\n\t\tif(!uvm_config_db#(virtual fifo_if)::get(this,\"\",\"vif\",vif))\n\t\t\t`uvm_fatal(\"fifo_driver\",\"virtual interface must be set for vif!!!\")\n\tendfunction\n\n    extern task main_phase(uvm_phase phase);\n    extern task drive_one_pkt(fifo_transaction tr);\nendclass\n\ntask fifo_driver::main_phase(uvm_phase phase);\n\t`uvm_info(\"fifo_driver\",\"begin!\",UVM_LOW)\n\twhile(1) begin\n\t\tseq_item_port.get_next_item(req); // 开始\n\t\tdrive_one_pkt(req);\n\t\tseq_item_port.item_done(); // 结束\n\tend\nendtask\n\ntask fifo_driver::drive_one_pkt(fifo_transaction tr);\n\tint data_size,j;\n\tdata_size = tr.data_in.size();\n\t`uvm_info(\"fifo_driver\",\"begin to drive one pkt\",UVM_LOW)\n\tfor(int i = 0; i < data_size; i++) begin\n\t\t@(vif.ckw); // 表示ckw中的内容发生变化\n\t\tif((!vif.ckw.wfull) && (vif.ckw.write == 1)) begin \n\t\t\tcov_label.sample(); \n\t\t\tvif.ckw.wdata <= tr.data_in[i];\n\t\t\t`uvm_info(\"fifo_driver\",$sformatf(\"%0d number is sent,number is %0h\",j++,vif.ckw.wdata),UVM_LOW) \n\t\tend  \n\t\telse if((!vif.ckw.wfull) && (vif.ckw.write == 0)) begin\n\t\t\tvif.ckw.write <= 1;\n\t\t\ti--;\n\t\tend \n\t\telse begin // 满了\n\t\t\tvif.ckw.write <= 0;\n\t\t\ti--;\n\t\tend\n\tend  \nendtask\n\n`endif\n```\n`关于覆盖率这里我们先不做介绍，后续会单独做期来讲解覆盖率`\n\n需要注意几点，首先在初始化函数中使用`uvm_config_db`来获取DUT信号，用于对DUT的信号进行写入与读取。\n其次是在main_phase中，使用driver自带的端口`seq_item_port`来获得一个包（就是刚才说的随机数据），这个端口会在agent中进行连接，来源就是sequencer，然后将包中的信息发送到DUT上。\n最后就是在drive_one_pkt中，使用`@(vif.ckw);`来捕获时钟上升沿，然后通过wfull和write的状态来决定是否发送数据。\n>可以看到，write和wdata信号均有写入和读取的操作，因此在ckw中设置为inout信号\n\n## 2.4 moniter\nmoniter的作用在于接受DUT的信息，有在输入和输出都有一个moniter。\n```java\n`ifndef FIFO_IN_MONITOR__SV\n`define FIFO_IN_MONITOR__SV\nclass fifo_in_monitor extends uvm_monitor;\n   virtual fifo_if vif;\n\n   uvm_analysis_port #(fifo_transaction)  ap;\n   // 注册\n   `uvm_component_utils(fifo_in_monitor)\n   // 构造函数\n   function new(string name = \"fifo_in_monitor\", uvm_component parent = null);\n      super.new(name, parent);\n   endfunction\n   // 初始化函数\n   virtual function void build_phase(uvm_phase phase);\n      super.build_phase(phase);\n      if(!uvm_config_db#(virtual fifo_if)::get(this, \"\", \"vif\", vif))\n         `uvm_fatal(\"fifo_in_monitor\", \"virtual interface must be set for vif!!!\")\n      ap = new(\"ap\", this);\n   endfunction\n\n   extern virtual task main_phase(uvm_phase phase);\n   extern task collect_one_pkt(fifo_transaction tr);\nendclass\n\ntask fifo_in_monitor::main_phase(uvm_phase phase);\n\tfifo_transaction tr;\n\trepeat(2) begin\n\t\ttr = new(\"tr\");\n\t\t#4.001;\n\t\tcollect_one_pkt(tr);\n\t\tap.write(tr);\n\tend\nendtask\n\ntask fifo_in_monitor::collect_one_pkt(fifo_transaction tr);\n\tint j,k;\n\t`uvm_info(\"in_monitor\",\"begin to collect one pkt\",UVM_LOW) \n\twhile(1) begin \n\t\t@(vif.ckim);  \n\t\tif((!vif.ckim.wfull) && (vif.ckim.write == 1)) begin // 符合要求\n\t\t\ttr.data_in[j] = vif.ckim.wdata;\n\t\t\t`uvm_info(\"in_monitor\",$sformatf(\"%0d number is received,number is %0h\",k++,vif.ckim.wdata),UVM_LOW)\n\t\t\tif(j == 199)  break;   //seq1 发送200个数据 \n\t\t\tj++;\n\t\tend \n\tend\n\t`uvm_info(\"in_monitor\",\"end collect one pkt\",UVM_LOW)\n\t//tr.print();\nendtask\n\n`endif\n```\n与driver一样，也要使用`uvm_config_db`来获取DUT信号。\n但是这里定义了一个`uvm_analysis_port`端口其作用就是把接收到的数据transcation发送出。\n这里的`#4.001`大概率是为了等待刚刚发送的数据发送，*这里挖一个坑*。\n后面的collect_one_pkt与前面相同，当符合要求后将wdata读到data_in中，但是这里使用的是ckim，原因如上所示。\n输出的out_moniter与输入有两个区别，一个是没有`#4.001`，第二个就是使用的读时钟块ckom以及传输的是rdata。\n## 2.5 sequencer\nsequencer相当于sequence的下手，用于帮sequence传递数据的。\n```java\n`ifndef FIFO_SEQUENCER__SV\n`define FIFO_SEQUENCER__SV\n\nclass fifo_sequencer extends uvm_sequencer #(fifo_transaction);\n   `uvm_component_utils(fifo_sequencer)\n\tfunction new(string name = \"fifo_sequencer\",uvm_component parent = null);\n\t\tsuper.new(name,parent);\n\tendfunction\n\t\n\ttask main_phase(uvm_phase phase);\n\t\t`uvm_info(\"fifo_sequencer\",\"main_phase begin\",UVM_LOW)\n\tendtask\nendclass\n\n`endif\n```\n代码里没有要讲的，仅仅就定义了一下自己。\n## 2.6 agent\nagent的作用仅仅就是将三巨头sequencer、driver和monitor进行连接。\n\n```java\n`ifndef FIFO_IN_AGENT__SV\n`define FIFO_IN_AGENT__SV\n\nclass fifo_in_agent extends uvm_agent ;\n   // 三巨头\n   fifo_sequencer       sqr;\n   fifo_driver          drv;\n   fifo_in_monitor      mon;\n   \n   uvm_analysis_port #(fifo_transaction)  ap; // 指向外面\n   `uvm_component_utils(fifo_in_agent)\n\n   function new(string name = \"fifo_in_agent\", uvm_component parent);\n      super.new(name, parent);\n   endfunction \n   \n   extern virtual function void build_phase(uvm_phase phase);\n   extern virtual function void connect_phase(uvm_phase phase);\nendclass\n\nfunction void fifo_in_agent::build_phase(uvm_phase phase);\n\tsuper.build_phase(phase);\n\tif(is_active == UVM_ACTIVE) begin\n\t\tdrv = fifo_driver::type_id::create(\"i_drv\",this);\n\t\tsqr = fifo_sequencer::type_id::create(\"i_sqr\",this); \n\tend\n\tmon = fifo_in_monitor::type_id::create(\"i_mon\",this);\nendfunction\n\nfunction void fifo_in_agent::connect_phase(uvm_phase phase);\n\tsuper.connect_phase(phase);\n\tif(is_active == UVM_ACTIVE) begin\n\t\tdrv.seq_item_port.connect(sqr.seq_item_export);\n\tend\n\tap = mon.ap; // 调用mon的ap指针\nendfunction\t\n`endif\n```\n需要注意的是，这里和moniter一样定义了一个`uvm_analysis_port `端口，并且在connect_phase中使用`ap = mon.ap;`的方式将mon的ap的指针指向了该ap，实现外部直接调用mon.ap。\n`is_active `是agent的固有方法，用来区分输入和输出。但是本项目中还定义了一个out_agent，这个方法应该冗余了。在out_agent中的mon变为out_mon，其余不变。\n在connect_phase连接中将sqr的输出与drv的输入连接，等待sqr提供数据。\n\n## 2.7 model\nmodel按理来说应该是一个参考，用来实现与DUT相同的操作，但这里仅仅定义了两个端口，从port端口到ap。\n```java\n`ifndef FIFO_MODEL__SV\n`define FIFO_MODEL__SV\n\nclass fifo_model extends uvm_component;\n   \n   uvm_blocking_get_port #(fifo_transaction)  port;\n   uvm_analysis_port #(fifo_transaction)  ap;\n\n   extern function new(string name, uvm_component parent);\n   extern function void build_phase(uvm_phase phase);\n   extern virtual  task main_phase(uvm_phase phase);\n\n   `uvm_component_utils(fifo_model)\nendclass \n\nfunction fifo_model::new(string name, uvm_component parent);\n   super.new(name, parent);\nendfunction \n\nfunction void fifo_model::build_phase(uvm_phase phase);\n   super.build_phase(phase);\n   port = new(\"port\", this);\n   ap = new(\"ap\", this);\nendfunction\n\ntask fifo_model::main_phase(uvm_phase phase);\n   fifo_transaction tr;\n   fifo_transaction new_tr;\n   super.main_phase(phase);\n   while(1) begin\n      port.get(tr);\n      new_tr = new(\"new_tr\");\n      new_tr.copy(tr);\n      `uvm_info(\"fifo_model\", \"get one transaction, copy and print it:\", UVM_LOW)\n      new_tr.print();\n      ap.write(new_tr);\n   end\nendtask\n`endif\n```\n## 2.8 scoreboard\nscoreboard用于收集来自agent以及model的数据。\n```java\n`ifndef FIFO_SCOREBOARD__SV\n`define FIFO_SCOREBOARD__SV\nclass fifo_scoreboard extends uvm_scoreboard;\n   fifo_transaction  expect_queue[$];\n   uvm_blocking_get_port #(fifo_transaction)  exp_port;\n   uvm_blocking_get_port #(fifo_transaction)  act_port;\n   `uvm_component_utils(fifo_scoreboard)\n\n   extern function new(string name, uvm_component parent = null);\n   extern virtual function void build_phase(uvm_phase phase);\n   extern virtual task main_phase(uvm_phase phase);\nendclass \n\nfunction fifo_scoreboard::new(string name, uvm_component parent = null);\n   super.new(name, parent);\nendfunction \n\nfunction void fifo_scoreboard::build_phase(uvm_phase phase);\n   super.build_phase(phase);\n   exp_port = new(\"exp_port\", this);\n   act_port = new(\"act_port\", this);\nendfunction \n\ntask fifo_scoreboard::main_phase(uvm_phase phase);\n   fifo_transaction  get_expect,  get_actual, tmp_tran;\n   bit result;\n \n   super.main_phase(phase);\n   fork \n      while (1) begin\n         exp_port.get(get_expect);\n         expect_queue.push_back(get_expect);\n      end\n      while (1) begin\n         act_port.get(get_actual);\n         if(expect_queue.size() > 0) begin\n            tmp_tran = expect_queue.pop_front();\n            result = get_actual.compare(tmp_tran);\n            if(result) begin \n               `uvm_info(\"fifo_scoreboard\", \"Compare SUCCESSFULLY\", UVM_LOW);\n            end\n            else begin\n               `uvm_error(\"fifo_scoreboard\", \"Compare FAILED\");\n               $display(\"the expect pkt is\");\n               tmp_tran.print();\n               $display(\"the actual pkt is\");\n               get_actual.print();\n            end\n         end\n         else begin\n            `uvm_error(\"fifo_scoreboard\", \"Received from DUT, while Expect Queue is empty\");\n            $display(\"the unexpected pkt is\");\n            get_actual.print();\n         end \n      end\n   join\nendtask\n`endif\n```\n这里定义了两个接受端口，分别是exp_port以及act_port，其中exp_port来自fifo_model的输入，表示参考的数据。act_port来自o_agt，表示DUT的输出值。将这两个数值进行比较，从而判断程序是否发生错误。\n## 2.9 env\nenv是整个UVM最接近顶层的存在，其主要包括三个部分：agent、model以及scoreboard。\n```java\n`ifndef MY_ENV__SV\n`define MY_ENV__SV\n\nclass my_env extends uvm_env;\n   fifo_in_agent     i_agt;\n   fifo_out_agent    o_agt;\n   fifo_model        mdl;\n   fifo_scoreboard   scb;\n   \n   uvm_tlm_analysis_fifo #(fifo_transaction) agt_scb_fifo;\n   uvm_tlm_analysis_fifo #(fifo_transaction) agt_mdl_fifo;\n   uvm_tlm_analysis_fifo #(fifo_transaction) mdl_scb_fifo;\n   \n   function new(string name = \"my_env\", uvm_component parent);\n      super.new(name, parent);\n   endfunction\n\n   virtual function void build_phase(uvm_phase phase);\n      super.build_phase(phase);\n      i_agt = fifo_in_agent::type_id::create(\"i_agt\", this);\n      o_agt = fifo_out_agent::type_id::create(\"o_agt\", this);\n      i_agt.is_active = UVM_ACTIVE;\n      o_agt.is_active = UVM_PASSIVE;\n      mdl = fifo_model::type_id::create(\"mdl\", this);\n      scb = fifo_scoreboard::type_id::create(\"scb\", this);\n      agt_scb_fifo = new(\"agt_scb_fifo\", this);\n      agt_mdl_fifo = new(\"agt_mdl_fifo\", this);\n      mdl_scb_fifo = new(\"mdl_scb_fifo\", this);\n   endfunction\n\n   extern virtual function void connect_phase(uvm_phase phase);\n   \n   `uvm_component_utils(my_env)\nendclass\n\nfunction void my_env::connect_phase(uvm_phase phase);\n   super.connect_phase(phase);\n   i_agt.ap.connect(agt_mdl_fifo.analysis_export);\n   mdl.port.connect(agt_mdl_fifo.blocking_get_export);\n   mdl.ap.connect(mdl_scb_fifo.analysis_export);\n   scb.exp_port.connect(mdl_scb_fifo.blocking_get_export);\n   o_agt.ap.connect(agt_scb_fifo.analysis_export);\n   scb.act_port.connect(agt_scb_fifo.blocking_get_export); \nendfunction\n\n`endif\n```\n这里面共定义了三个fifo，用来构建三者之间数据的缓冲，具体传输方向如下所示：\nfifo_model -> mdl_scb_fifo -> fifo_scoreboard\nfifo_out_agent-> agt_scb_fifo-> fifo_scoreboard\nfifo_in_agent -> agt_scb_fifo -> fifo_model \n从这里看也看到，在fifo_model 中传递的数据，其实是来自于fifo_in_agent ，当然，最为fifo输入和输出的数据确实是相同的。\n## 2.10 base_test\nbase_test才是UVM真正的顶层，他的主要作用很简单，除了例化一个env之外，还可以进行项目错误的统计工作。\n```java\n`ifndef BASE_TEST__SV\n`define BASE_TEST__SV\n\nclass base_test extends uvm_test;\n   my_env         env;\n   \n   function new(string name = \"base_test\", uvm_component parent = null);\n      super.new(name,parent);\n   endfunction\n   \n   extern virtual function void build_phase(uvm_phase phase);\n   extern virtual function void report_phase(uvm_phase phase);\n   `uvm_component_utils(base_test)\nendclass\n\nfunction void base_test::build_phase(uvm_phase phase);\n   super.build_phase(phase);\n   env  =  my_env::type_id::create(\"env\", this);\nendfunction\n\nfunction void base_test::report_phase(uvm_phase phase);\n   uvm_report_server server;\n   int err_num;\n   super.report_phase(phase);\n\n   server = get_report_server();\n   err_num = server.get_severity_count(UVM_ERROR);\n\n   if (err_num != 0) begin\n      $display(\"TEST CASE FAILED\");\n   end\n   else begin\n      $display(\"TEST CASE PASSED\");\n   end\nendfunction\n\n`endif\n```\n在report_phase中定义了一个`uvm_report_server `用于检测错误，根据错误的数目输出验证通过与否。\n## 2.11 case_sequence\n这个相当于独立于整个UVM树之外的一个部分，用于产生激励信号。\n```java\n`ifndef FIFO_CASE0__SV\n`define FIFO_CASE0__SV\n\nclass case0_sequence extends uvm_sequence #(fifo_transaction);\n\tfifo_transaction trans;\n\t`uvm_object_utils(case0_sequence)\n\n\tfunction new(string name = \"case0_sequence\");\n\t\tsuper.new(name);\n\tendfunction\n\n\tvirtual task body();\n\t\trepeat(2) begin\n\t\t\t`uvm_info(\"case0_sequence\",\"generate one transaction!\",UVM_LOW)\n\t\t\t`uvm_do_with(trans,{trans.data_in.size == 200;})\n\t\tend\n\tendtask\nendclass\n\nclass test_case0 extends base_test;\n\t`uvm_component_utils(test_case0)\n\n\tfunction new(string name = \"test_case0\", uvm_component parent = null);\n\t\tsuper.new(name,parent);\n\tendfunction\n\n\tfunction void build_phase(uvm_phase phase);\n\t\tsuper.build_phase(phase);\n\tendfunction\n\t\n\ttask main_phase(uvm_phase phase);\n\t\tcase0_sequence seq;\n\t\tphase.raise_objection(this);\n\t\t#4;  \n\t\tseq = case0_sequence::type_id::create(\"l_seq\");\n\t\t`uvm_info(\"case0_sequence\",\"case1_sequence begin\",UVM_LOW)\n\t\tseq.start(env.i_agt.sqr);\n\t\t#3000;\n\t\tphase.drop_objection(this);\n\tendtask\nendclass\n\n`endif\n```\n在这里，使用`uvm_do_with`宏的方法实现将特定的数据传输到sequencer。但这里值得注意的是，在下面定义了一个从属于base_test的类test_case0 ，其也是UVM树的一部分，是从属于base_test的，因此与env的关系很近，但是这里其作用仅仅就是建立一个case0_sequence 并且运行，同时还是用`phase.raise_objection(this)`与`phase.drop_objection(this)`定义整个sequence事件的开始与结束。在这里指定了`env.i_agt.sqr`为发射的地点。\n## 2.12 top_tb\n这就是最终的tb文件，代码如下，具体就不说了，无非就是例化初始化之类的操作，以及保存波形。\n>这里挖一个坑，针对这里`asyn_fifo_chk_rst`还没了解清楚。\n\n```java\n`timescale 1ns/1ps\n`include \"uvm_macros.svh\"\n\nimport asyn_fifo_chk_rst::*;\nimport uvm_pkg::*;\n\nmodule top_tb();\n\nlogic wclk,rclk,wreset_b,rreset_b;\n\nfifo_if my_if(wclk,rclk,wreset_b,rreset_b);\n\nfifo_top DUT\n(\n\t.wclk\t\t   (wclk),\n\t.rclk\t\t   (rclk),\n\t.wreset_b\t(wreset_b),     //wrst_n -> wreset_b\n\t.rreset_b\t(rreset_b),\t    //rrst_n -> rreset_b\n\t.write\t\t(my_if.write),\t//winc -> write\n\t.read\t\t   (my_if.read),\t//rinc -> read\n\t.wdata\t\t(my_if.wdata),\n\t.wfull\t\t(my_if.wfull),\n\t.rempty\t\t(my_if.rempty),\n\t.rdata\t\t(my_if.rdata)\n);\n\nfifo_rst_mon fifo_rst_mon1;\nfifo_chk_rst fifo_chk_rst1;\nevent reset_e_w;\nevent reset_e_r;\n\ninitial begin\n\twclk = 0;\n\trclk = 0;\n\twreset_b = 1;\n\trreset_b = 1;\n\t#2 \n   wreset_b = 0;\n\trreset_b = 0;\n\tmy_if.write = 0;\n\tmy_if.read = 0;\n\t#2 \n   wreset_b = 1;\n\trreset_b = 1;\nend\n\t\nalways #1 wclk = ~wclk;\nalways #3 rclk = ~rclk;\n\n// 参数传递\ninitial begin\n\tuvm_config_db#(virtual fifo_if)::set(null,\"uvm_test_top.env.i_agt.i_drv\",\"vif\",my_if);\n\tuvm_config_db#(virtual fifo_if)::set(null,\"uvm_test_top.env.i_agt.i_mon\",\"vif\",my_if);\n\tuvm_config_db#(virtual fifo_if)::set(null,\"uvm_test_top.env.o_agt.o_mon\",\"vif\",my_if);\nend\n\n// 参考？\ninitial begin\n\tfifo_rst_mon1 = new(reset_e_w,reset_e_r);\n\tfifo_chk_rst1 = new(reset_e_w,reset_e_r);\n\tfifo_rst_mon1.my_if6 = my_if;\n\tfifo_chk_rst1.my_if7 = my_if;\n\tfork\n\t\tfifo_rst_mon1.run();\n\t\tfifo_chk_rst1.run();\n\tjoin\nend\n\ninitial begin\n\t$fsdbDumpfile(\"tb.fsdb\");\n\t$fsdbDumpvars;\n\t$fsdbDumpon;\nend\n\ninitial begin\n   run_test(\"test_case0\");\nend\n\nendmodule\n```\n# 三、UVM仿真环境的搭建\n这里我简单说一下，因为在环境搭建的过程中踩了很多坑，在网上的教程很乱，也没有一个完美的答案，这里就介绍一下我搭建UVM的结构图：\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/922427ad5a5945d795bb6a1a480a8062.png\" height=500 >\n</div>\n\n可以看出，我这里建立了三个文件夹，有源码DUT部分，存放仿真文件以及启动文件的sim还有存放tb文件和uvm文件的testbench文件。最重要的就是启动文件filelist和Makefile的编写。\n## 3.1 Makefile文件的编写\n先给出我的Makefile文件：\n```c\n.PHONY:file vcs sim verdi clean\n\nVCS = vcs -full64 -cpp g++-4.8 -cc gcc-4.8 \\\n\t-LDFLAGS -Wl,--no-as-needed \\\n\t-f filelist.f \\\n\t-timescale=1ns/1ps \\\n\t-R \\\n\t-debug_acc+all \\\n\t+define+FSDB \\\n\t-lca -kdb \\\n\t-ntb_opts uvm-1.1 \\\n\t-sverilog \\\n\t+v2k \\\n\t|tee vcs.log\n\t\nfile:\n\tfind ../ -name \"*.v\" -o -name \"*.sv\" > file.f\n\t\nvcs:\n\t${VCS}\n\nsim:\n\t./simv -gui |tee sim.log &\n\nverdi:\n\tverdi -f filelist.f -sv -ssf tb.fsdb &\n\nclean:\n\trm -rf csrc verdiLog simv.daidir \\\n\tnovas.* \\\n\tvc_hdrs.h \\\n\tsimv \\\n\t*.key \\\n\t*.fsdb \\\n\t*.log \\\n\tinter.vpd \\\n\tDVEfiles\n```\n这里包括了五个部分，分别是file、vcs、sim、verdi以及clean。我分开来介绍：\n\n- file：\n这个主要是用于生成filelist文件，但也不全是filelist，因为该脚本只能获取所有的.v和.sv文件，在filelist中的编写不仅仅要包含这个，而且还有uvm包的文件，并且这些文件的先后顺序有严格的要求，这个后面讲解。\n- vcs：\n这个主要是启动vcs对所有的文件进行编译，在Makefile中添加了很多附加选项，这些选项都是能够让vcs正常运行的选项，你可以使用`vcs help`来获取vcs命令手册，里面解释了所有符号的意义以及用法。\n```py\n# 指定使用 VCS (Verilog Compiler Simulator) 进行仿真编译\nVCS = vcs -full64 -cpp g++-4.8 -cc gcc-4.8 \\\n\t# -full64: 使用 64 位编译选项，适用于 64 位操作系统\n\t# -cpp g++-4.8: 指定 C++ 编译器使用 g++ 版本 4.8\n\t# -cc gcc-4.8: 指定 C 编译器使用 gcc 版本 4.8\n\t-LDFLAGS -Wl,--no-as-needed \\\n\t# -LDFLAGS: 启用链接器的标志\n\t# -Wl,--no-as-needed: 在链接时告诉链接器不要自动移除未使用的库\n\t-f filelist.f \\\n\t# -f filelist.f: 指定仿真源文件列表，filelist.f 是一个包含所有待编译文件的文件列表\n\t-timescale=1ns/1ps \\\n\t# -timescale=1ns/1ps: 设置仿真时间尺度为 1ns（纳秒）/ 1ps（皮秒）\n\t-R \\\n\t# -R: 启用调试和恢复功能\n\t-debug_acc+all \\\n\t# -debug_acc+all: 启用所有的调试访问器，允许调试仿真时查看所有信号和变量\n\t+define+FSDB \\\n\t# +define+FSDB: 定义一个名为 FSDB 的宏，通常用于控制 FSDB 文件（仿真波形文件）的输出\n\t-lca -kdb \\\n\t# -lca: 启用 LCA (Library Coverage Analysis)，用于库覆盖分析\n\t# -kdb: 启用 KDB (Kernel Debugger)，为调试目的启用内核调试功能\n\t-ntb_opts uvm-1.1 \\\n\t# -ntb_opts uvm-1.1: 启用与 UVM 1.1 兼容的 NTB（Native Testbench）选项，适用于 UVM（Universal Verification Methodology）验证环境\n\t-sverilog \\\n\t# -sverilog: 启用 SystemVerilog 编译支持\n\t+v2k \\\n\t# +v2k: 启用 Verilog-2001（V2K）编译选项\n\t|tee vcs.log\n\t# |tee vcs.log: 使用 tee 命令将 VCS 编译过程的输出同时显示在终端并保存到 vcs.log 文件中\n```\n\n- sim：用来使用vcs自带的仿真工具生成波形，这里我没用过。\n- verdi：用来查看fsdb的波形文件，这个是我最常用的，通过这个可以很方便的对波形进行追溯，调试起来很容易。\n- clean：用来删除生成了的文件。\n\n以防有人不会用Makefile，说一下他的用法。在Makefile文件所在的目录打开终端，使用`make [指令]`的方式来运行，Makefile本质来说就是将指令进行了一个打包，我这里运行`verdi -f filelist.f -sv -ssf tb.fsdb &`和`make verdi`的效果是一样的。\n## 3.2 filelist文件的编写\n下面是我针对本项目编写的filelist文件。\n```\n+incdir+$UVM_HOME/src\n$UVM_HOME/src/uvm_pkg.sv\n\n../testbench/fifo_if.sv\n../testbench/fifo_transaction.sv\n../testbench/fifo_driver.sv\n../testbench/fifo_in_sequencer.sv\n../testbench/fifo_in_monitor.sv\n../testbench/fifo_out_monitor.sv\n../testbench/fifo_in_agent.sv\n../testbench/fifo_out_agent.sv\n../testbench/fifo_model.sv\n../testbench/fifo_scoreboard.sv\n../testbench/my_env.sv\n../testbench/fifo_chk_rst.sv\n../testbench/base_test.sv\n../testbench/fifo_case0.sv\n../testbench/top_tb.sv\n\n../DUT/pointer.v\n../DUT/sync.v\n../DUT/fifo_top.v\n../DUT/memory.v\n../DUT/comparator.v\n```\n可以分为三个部分，首先是前两行的`+incdir+$UVM_HOME/src`和`$UVM_HOME/src/uvm_pkg.sv`，第一句话表示将`$UVM_HOME/src`中的所有文件加入到编译列表中，这个文件里基本上是所有uvm库所需要的文件，什么uvm_env呀之类的就是这里定义。然后`uvm_pkg.sv`相当于是所有文件的核心实现，在tob_tb中，只需要调用`import uvm_pkg::*;`便可以将所有uvm包含进来。\n>$UVM_HOME表示的是一个宏定义，在Lunix中主目录的`.bashrc`中定义，我这里的原话是`export UVM_HOME=/home/wxm/uvm_study/uvm-1.1d`\n后面紧接着是testbench中的文件，注意一定要先写testbench再写dut，以防报错。然后在testbench内部也要按照顺序，从独立到树枝再到树根的顺序，比如献血interface和transaction，再从树枝的dirver开始写到树根base_case。因为在UVM编译的过程中是从上到下的顺序，如果你先编译base_case，编译器会报错说找不到env。最后就是top_tb以及其余的DUT文件。\n>但是貌似DUT文件没有内部顺序\n\n## 3.3 另辟蹊径\n还有一个别的方法，你只需要写两个文件就可以：一个是`top_tb.sv`;另一个是`fifo_top.v`，前提是你需要在这两个文件里面把其余所有的文件include一遍，就像这样：\n```\n`include \"../testbench/my_driver.sv\"\n`include \"../testbench/my_model.sv\"\n...\n```\n因为你的Makefile和filelist以及终端运行的位置都在sim文件夹，而其他文件在testbench和dut文件夹，因此你在include的时候需要以sim文件夹为根目录，使用`../`回到上一级，再使用`/testbench/XXX.sv`来调用这些文件。这样操作就不需要在filelist中调整顺序了。\n\n---\n# 总结\n总而言之，这是一个很好的练习UVM的项目，因为其与《UVM实战》这本书的内容大差不差，很多在结构上都有相似的地方，我希望从这个项目为起点，依次加深我对IC验证这一领域的认识。后面我会对该项目的波形图进行研究，并通过调整UVM代码实现一些不一样的功能。\n","tags":["UVM","简单ic模块"],"categories":["UVM学习笔记"]},{"title":"【UVM学习笔记】UVM验证平台的运行—Phase以及objection","url":"/2025/04/16/130da575206a/","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n---\n\n# 一、phase机制\n## 1.1 task phase与function phase\n\nUVM中的phase，按照其是否消耗仿真时间的特性，可以分成两大类,一类是function phase，如build_phase、connect_phase等，这些phase都不耗费仿真时间，通过函数来实现；另外一类是task phase，如run_phase等，它们耗费仿真时间，通过任务来实现。\n灰色背景所示的是task phase，其他为function phase。\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/aaf62ae602a4440c9dd7e022a9dedf85.png\" height=300 >\n</div>\n\n值得注意的是，task phase中，run_phase和pre_reset_phase等12个小的phase并行运行。后者称为动态运行的phase。\n分成小的phase是为了实现更加精细化的控制。reset、configure、main、shutdown四个phase是核心，这四个phase通常模拟DUT的正常工作方式，在reset_phase对DUT进行复位、初始化等操作，在configure_phase则进行DUT的配置，DUT的运行主要在main_phase完成，shutdown_phase则是做一些与DUT断电相关的操作。\n## 1.2 代码执行顺序\n对于UVM树来说，共有三种顺序可以选择，一是自上而下，二是自下而上，三是随机序。最后一种方式是不受人控制的，在编程当中，这种不受控制的代码越少越好。因此可以选择的无非就是自上而下或者自下而上。\n除了build_phase之外，所有不耗费仿真时间的phase(即function phase)都是自下而上执行的。\n对于同一层次的、具有兄弟关系的component，其执行顺序是按照字典序的。\n## 1.3 super.phase的内容\n对于build_phase来说，uvm_component对其做的最重要的事情就是自动获取通过config_db::set设置的参数。除build_phase外,在写其他phase时,完全可以不必加上super.xxxx_phase语句。\n## 1.4 phase的跳转\nphase的跳转是比较高级的功能，假如在验证平台中监测到reset_n信号为低电平,则马上从main_phase跳转到reset_phase。driver的代码如下:\n```java\ntask my_driver::reset_phase(uvm_phase phase);\n   phase.raise_objection(this); \n   `uvm_info(\"driver\", \"reset phase\", UVM_LOW)\n   vif.data <= 8'b0;\n   vif.valid <= 1'b0;\n   while(!vif.rst_n)\n      @(posedge vif.clk);\n   phase.drop_objection(this); \nendtask\n\ntask my_driver::main_phase(uvm_phase phase);\n   `uvm_info(\"driver\", \"main phase\", UVM_LOW)\n   fork\n      while(1) begin\n         seq_item_port.get_next_item(req);\n         drive_one_pkt(req);\n         seq_item_port.item_done();\n      end\n      begin\n         @(negedge vif.rst_n);\n         phase.jump(uvm_reset_phase::get());\n      end\n   join\nendtask\n```\nreset_phase主要做一些清理工作,并等待复位完成。main_phase中一旦监测到reset_n为低电平,则马上跳转到reset_phase。\n# 二、objection机制\nobjection字面的意思就是反对、异议。在验证平台中，可以通过drop_objection来通知系统可以关闭验证平台。当然，在撤销之前首先要raise_objection\n如果UVM发现此phase没有提起任何objection,那么将会直接跳转到下一个phase中。\n一般来说,在一个实际的验证平台中,通常会在以下两种objection的控制策略中选择一种:  \n## 2.1 在scoreboard中进行控制\n如果要在scoreboard中控制objection，则需要通过config_db::set的方式设置收集到的transaction的数量pkt_num，当收集到足够数量的transaction后跳出循环：\n```java\ntask my_scoreboard::main_phase(uvm_phase phase); \n\tphase.raise_objection(this); \n\tfork \n\t\twhile (1) begin \n\t\t\texp_port.get(get_expect); \n\t\t\texpect_queue.push_back(get_expect); \n\t\tend \n\t\tfor(int i = 0; i < pkt_num; i++) begin \n\t\t\tact_port.get(get_actual); \n\t\t\t...  \n\t\tend\n\tjoin_any \n\tphase.drop_objection(this); \nendtask\n```\n上述代码中将原本的fork...join语句改为了fork...join_any。当收集到足够的transaction后，第二个进程终结，从而跳出fork...join_any，执行drop_objection语句。\n## 2.1 在sequence中进行控制\n当sequence完成后,再撤销此objection。这里就是之前章节的例子：\n```java\ntask my_case0::main_phase(uvm_phase phase);\n   phase.raise_objection(this);\n   `uvm_info(\"case0\", \"main_phase\", UVM_LOW)\n   #10000;\n   phase.drop_objection(this);\nendtask\n```\n以上两种方式在验证平台中都有应用。其中用得最多的是第二种,这种方式是UVM提倡的方式。UVM的设计哲学就是全部  由sequence来控制激励的生成,因此一般情况下只在sequence中控制objection。\n但是有一个问题就是：在sequence中，n时刻发送完毕最后一个transaction，如果此时立刻drop_objection，那么最后在n+p时刻DUT输出的包将无法接收到。因此,在sequence中，最后一个包发送完毕后，要延时p时间才能drop_objection，对应的图如下所示：\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/1320ea55339349eb9cd2867a6a16db27.png\" height=400 >\n</div>\n\n```java\nvirtual task body(); \n\tif(starting_phase != null) \n\t\tstarting_phase.raise_objection(this); \n\trepeat (10) begin \n\t\t`uvm_do(m_trans) \n\tend \n\t#100; \n\tif(starting_phase != null) \n\t\tstarting_phase.drop_objection(this); \nendtask\n```\n还有一种方法就是在最顶层运行下面的代码：\n```java\nphase.phase_done.set_drain_time(this, 200);\n```\n这样在你撤销drop_objection后还会等待一段时间，提高了灵活性。\n\n# 二、domain机制\n在默认情况下，验证平台中所有component都位于一个名字为common_domain的domain中，假设有两个driver，那么两者在每一个phase的运行都是同步的。若要体现出独立性,那么两个部分的reset_phase、configure_phae、main_phase等就不应该同步。此时就应该让其中的一部分从common_domain中独立出来，使其位于不同的domain中。\n下面是两个在不同的domain的情况：\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/95189bdac85a4426b39cabad71dfbff3.png\" height=350 >\n</div>\n\ndomain把两块时钟域隔开，之后两个时钟域内的各个动态运行(run_time)的phase就可以不必同步。注意，这里domain只能隔离run-time的phase，对于其他phase，其实还是同步的。\n若将某个component置于某个新的domain中，可以使用如下的方式：\n```java\nclass B extends uvm_component;\n   uvm_domain new_domain;\n   `uvm_component_utils(B)\n\n   function new(string name, uvm_component parent);\n      super.new(name, parent);\n      new_domain = new(\"new_domain\");\n   endfunction\n\n   virtual function void connect_phase(uvm_phase phase);\n      set_domain(new_domain);\n   endfunction\n\n   extern virtual  task reset_phase(uvm_phase phase);\n   extern virtual  task post_reset_phase(uvm_phase phase);\n   extern virtual  task main_phase(uvm_phase phase);\n   extern virtual  task post_main_phase(uvm_phase phase);\nendclass\n```\n这样B就是单独一个domain了，然后再运行的话会发现两者的运行时间发生了错位。\n刚才的A和B分别位于不同的domain中,在此种情况下,phase的跳转将只局限于某一个domain中。\n```java\nclass B extends uvm_component;\n   uvm_domain new_domain;\n   bit has_jumped;\n   `uvm_component_utils(B)\n\n   function new(string name, uvm_component parent);\n      super.new(name, parent);\n      new_domain = new(\"new_domain\");\n      has_jumped = 0;\n   endfunction\n\n   virtual function void connect_phase(uvm_phase phase);\n      set_domain(new_domain);\n   endfunction\n\n   extern virtual  task reset_phase(uvm_phase phase);\n   extern virtual  task main_phase(uvm_phase phase);\nendclass\n\ntask B::reset_phase(uvm_phase phase);\n   phase.raise_objection(this);\n   `uvm_info(\"B\", \"enter into reset phase\", UVM_LOW)\n   #100;\n   phase.drop_objection(this);\nendtask\n\ntask B::main_phase(uvm_phase phase);\n   phase.raise_objection(this);\n   `uvm_info(\"B\", \"enter into main phase\", UVM_LOW)\n   #500;\n   if(!has_jumped) begin\n      phase.jump(uvm_reset_phase::get());\n      has_jumped = 1'b1;\n   end\n   phase.drop_objection(this);\nendtask\n```\n运行的结果是B两次进入了reset_phase和main_phase，而A只进入了一次。domain的应用使得phase的跳转可以只局限于验证平台的一部分。\n# 总结\n\n在这一章主要讲述了在UVM中每一个phase的运算顺序，有的是一瞬间运行，一个是需要消耗仿真时间，同时还在跳转、独立性等方面进行了讨论，能够帮助读者更加灵活的进行代码的编写。\n","tags":["UVM"],"categories":["UVM学习笔记"]},{"title":"【UVM学习笔记】UVM中的“类”","url":"/2025/04/16/7fdd63537fc6/","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n---\n\n# 一、UVM派生结构\n\n在上一篇博客讲述了UVM的结构，大家可以发现所有的结构分为两大类，一个是uvm_component，另一个是uvm_object。\nuvm_object是UVM中最基本的类,读者能想到的几乎所有的类都继承自uvm_object，包括uvm_component。uvm_component有两大特性是uvm_object所没有的，一是通过在new的时候指定parent参数来形成一种树形的组织结构，二是有phase的自动执行特点。下面是整个UVM类的派生图：\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/87e82a770ff145c783f504c47290c2bb.png\" height=300 >\n</div>\n\n## 1.1 来自uvm_object的类\n既然uvm_object是最基本的类,那么其能力恰恰也是最差的,当然了,其扩展性也是最好的。下面这几个是派生与其的类：\n1. uvm_sequence_item：之前定义的所有的transaction要从uvm_sequence_item派生。在UVM中，不能从uvm_transaction派生一个transaction，而要从uvm_sequence_item派生。因为uvm_sequence_item是从uvm_transaction派生而来的，因此uvm_sequence_item相比uvm_transaction添加了很多实用的成员变量和函数/任务。\n2. uvm_sequence：所有的sequence要从uvm_sequence派生。sequence就是sequence_item的组合。\n3. config：所有的config一般直接从uvm_object派生。config的主要功能就是规范验证平台的行为方式。如规定driver在读取总线时  地址信号要持续几个时钟,片选信号从什么时候开始有效等。但是不要和前面的uvm_config_db搞混了\n\n除了这些，还有一些没有见过的：\n- uvm_reg_item派生自uvm_sequence_item,用于register model中。\n- uvm_reg_map、uvm_mem、uvm_reg_field、uvm_reg、uvm_reg_file、uvm_reg_block等与寄存器相关的众多的类都是派生自uvm_object，它们都是用于register model。\n- uvm_phase派生自uvm_object，其主要作用为控制uvm_component的行为方式,使得uvm_component平滑地在各个不同的phase之间依次运转。\n\n## 1.2 来自uvm_component的类\n这个就是上一篇博客中树的各个部分了。\n- uvm_driver：所有的driver都要派生自uvm_driver。driver的功能主要就是向sequencer索要sequence_item，并且将sequence_item里的信息驱动到DUT的端口上。\n下面是其成员变量：\n```java\nuvm_seq_item_pull_port #(REQ, RSP) seq_item_port; \nuvm_seq_item_pull_port #(REQ, RSP) seq_item_prod_if; // alias \nuvm_analysis_port #(RSP) rsp_port; \nREQ req; \nRSP rsp;\n```\n- uvm_monitor：所有的monitor都要派生自uvm_monitor。monitor做的事情与driver相反，driver向DUT的pin上发送数据，而monitor则是从DUT的pin上接收数据，并且把接收到的数据转换成transaction级别的sequence_item，再把转换后的数据发送给scoreboard。\n- uvm_sequencer：所有的sequencer都要派生自uvm_sequencer。sequencer的功能就是组织管理sequence，当driver要求数据时,  它就把sequence生成的sequence_item转发给driver。\n- uvm_scoreboard：一般的scoreboard都要派生自uvm_scoreboard。scoreboard的功能就是比较reference model和monitor分别发送来的数据,根据比较结果判断DUT是否正确工作。\n- reference model：UVM中并没有针对reference model定义一个类。所以通常来说，reference model都是直接派生自uvm_component。reference model的作用就是模仿DUT，完成与DUT相同的功能。\n- uvm_agent：所有的agent要派生自uvm_agent。与前面几个比起来，uvm_agent的作用并不是那么明显。它只是把driver和monitor封装在一起，根据参数值来决定是只实例化monitor还是要同时实例化driver和monitor。\n- uvm_env：所有的env(environment的缩写)要派生自uvm_env。env将验证平台上用到的固定不变的component都封装在一起。\n- uvm_test：所有的测试用例要派生自uvm_test或其派生类，不同的测试用例之间差异很大，所以从uvm_test派生出来的类各不相同。\n\n# 二、UVM中打印信息的控制\n## 2.1 冗余度\nUVM通过冗余度级别的设置提高了仿真日志的可读性。在打印信息之前，UVM会比较要显示信息的冗余度级别与默认的冗余度阈值，如果小于等于阈值，就会显示，否则不会显示。\n默认的冗余度阈值是UVM_MEDIUM，所有低于等于UVM_MEDIUM(如UVM_LOW)的信息都会被打印出来。\n## 2.2 重载\n重载是深入到UVM骨子里的一个特性。UVM默认有四种信息严重性:UVM_INFO、UVM_WARNING、UVM_ERROR、  UVM_FATAL。这四种严重性可以互相重载。\n## 2.3 UVM_ERROR到达一定数量结束仿真\n当uvm_fatal出现时,表示出现了致命错误,仿真会马上停止。UVM同样支持UVM_ERROR达到一定数量时结束仿真。这个功能非常有用。\n实现这个功能的是set_report_max_quit_count函数：\n```java\nfunction void base_test::build_phase(uvm_phase phase);\n   super.build_phase(phase);\n   env  =  my_env::type_id::create(\"env\", this); \n   set_report_max_quit_count(5);\nendfunction\n```\n## 2.4 UVM的断点功能\n在程序调试时，断点功能是非常有用的一个功能。\n在程序运行时，预先在某语句处设置一断点。当程序执行到此处时，停止仿真，进入交互模式，从而进行调试。\n断点功能需要从仿真器的角度进行设置，不同仿真器的设置方式不同。为了消除这些设置方式的不同，UVM支持内建的断点功能，当执行到断点时，自动停止仿真，进入交互模式：\n```java\nenv.i_agt.drv.set_report_severity_action(UVM_WARNING, UVM_DISPLAY| UVM_STOP);\n```\n## 2.5 将输出信息导入文件中\nUVM会将UVM_INFO等信息显示在标准输出(终端屏幕)上。各个仿真器提供将显示在标准输出的信息同时输出到一个日志文件中的功能。\n```java\n   virtual function void connect_phase(uvm_phase phase);\n       driver_log = $fopen(\"driver.log\", \"w\");\n       drv_log = $fopen(\"drv.log\", \"w\");\n       env.i_agt.drv.set_report_severity_id_file(UVM_WARNING, \"my_driver\", driver_log);\n       env.i_agt.drv.set_report_severity_id_file(UVM_INFO, \"my_drv\", drv_log);\n       env.i_agt.drv.set_report_id_action(\"my_driver\", UVM_DISPLAY| UVM_LOG);\n       env.i_agt.drv.set_report_id_action(\"my_drv\", UVM_DISPLAY| UVM_LOG);\n   endfunction\n```\n上述代码将env.i_agt.drv的UVM_INFO输出到info.log，UVM_WARNING输出到warning.log，UVM_ERROR输出到error.log，  UVM_FATAL输出到fatal.log。\n## 2.5 控制打印信息的行为\n有很多宏定义：\n```java\ntypedef enum {  \n\t UVM_NO_ACTION = 'b000000,\n\t UVM_DISPLAY = 'b000001, \n\t UVM_LOG = 'b000010, \n\t UVM_COUNT = 'b000100, \n\t UVM_EXIT = 'b001000, \n\t UVM_CALL_HOOK = 'b010000, \n\t UVM_STOP = 'b100000 \n } uvm_action_type;\n ```\n其中UVM_NO_ACTION是不做任何操作;UVM_DISPLAY是输出到标准输出上;UVM_LOG是输出到日志文件中,它能工作  的前提是设置好了日志文件;UVM_COUNT是作为计数目标;UVM_EXIT是直接退出仿真;UVM_CALL_HOOK是调用一个回调  函数;UVM_STOP是停止仿真,进入命令行交互模式。\n\n# 三、config_db机制\n路径和层次结构是两个不同的概念，如果你使用了下面的代码：\n```java\ndrv = my_driver::type_id::create(\"driver\");\n```\n这样的话，那么drv在my_casen看来，层次结构依然是env.i_agt.drv，但其路径变为了env.i_agt.driver。在好的编码习惯中，这种变量名与 其实例化时传递的名字不一致的情况应该尽量避免。\n## 3.1 set与get函数的参数\nconfig_db机制用于在UVM验证平台间传递参数。set函数是寄信，而get函数是收信。代码如下：\n```java\nuvm_config_db#(int)::set(this, \"env.i_agt.drv\", \"pre_num\", 100);\n```\n其中第一个和第二个参数联合起来组成目标路径，与此路径符合的目标才能收信。第一个参数必须是一个uvm_component实例的指针，第二个参数是相对此实例的路径。第三个参数表示一个记号，用以说明这个值是传给目标中的哪个成员的，第四个参数是要设置的值。\n在driver中的build_phase使用如下方式收信：\n```java\nuvm_config_db#(int)::get(this, \"\", \"pre_num\", pre_num);\n```\nget函数中的第一个参数和第二个参数联合起来组成路径。\n## 3.2 跨层次的多重设置\n假如uvm_test_top和env中都对driver的pre_num的值进行了设置，获得的数值还是uvm_test_top，UVM规定层次越高,那么它的优先级越高。这里的层次指的是在UVM  树中的位置,越靠近根结点uvm_top,则认为其层次越高。\n当跨层次来看待问题时，是高层次的set设置优先；当处于同一层次时，上节已经提过，是时间优先。\n## 3.3 非直线的设置与获取\n若在其他component，如scoreboard中，对driver的某些变量使用config_db机制进行设置,则称为非直线的设置，我们应该尽量避免这种方式。\n\n\n# 总结\n\n本次描述了在上一节定义的众多组件的详细介绍，能够让我们更加深刻的了解UVM各组件之间的协调运转。\n\n","tags":["UVM"],"categories":["UVM学习笔记"]},{"title":"【UVM学习笔记】更加灵活的UVM—通信","url":"/2025/04/16/e224389c0e0d/","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n---\n\n# 一、TLM是什么？\n\nTLM是Transaction Level Modeling(事务级建模)的缩写。所谓transaction level是相对DUT中各个模块之间信号线级别的通信来说的。\nTLM通常有三种模式：\n1. put操作，通信的发起者A把一个transaction发送给B。在这个过程中，A称为“发起者”，而B称为“目标”。A具有的端口(用方框表示)称为PORT，而B的端口(用圆圈表示)称为EXPORT。这个过程中，数据流是从A流向B的。\n2. get操作。在这个过程中，A依然是“发起者”，B依然是“目标”，A上的端口依然是PORT，而B上的端口依然是EXPORT。这个过程中,数据流是从B流向A的。PORT和EXPORT体现的是控制流而不是数据流。\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/6fde0b06fb0d469ca26c326695b56f74.png\" height=250 >\n</div>\n\n4. transport操作，transport操作相当于一次put操作加一次get操作，这两次操作的“发起者”都是A，目标都是B。在这个过程中,数据流先从A流向B，再从B流向A。在现实世界中,  相当于是A向B提交了一个请求(request),而B返回给A一个应答(response)。\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/3d1e5110e48d48408bd95e21d1a2ff84.png\" height=250 >\n</div>\n\n# 二、put操作\n## 2.1、建立PORT和EXPORT的连接\nUVM中使用connect函数来建立连接关系。如A要和B通信(A是发起者)，那么可以这么写：A.port.connect(B.export)。下面是A的代码部分：\n```java\nclass A extends uvm_component;\n   `uvm_component_utils(A)\n\n   uvm_blocking_put_port#(my_transaction) A_port;\n   function new(string name, uvm_component parent);\n      super.new(name, parent);\n   endfunction\n\n   extern function void build_phase(uvm_phase phase);\n   extern virtual  task main_phase(uvm_phase phase);\nendclass\n\nfunction void A::build_phase(uvm_phase phase);\n   super.build_phase(phase);\n   A_port = new(\"A_port\", this);\nendfunction\n\ntask A::main_phase(uvm_phase phase);\nendtask\n```\n然后得到B的代码：\n```java\nclass B extends uvm_component;\n   `uvm_component_utils(B)\n\n   uvm_blocking_put_export#(my_transaction) B_export;\n   function new(string name, uvm_component parent);\n      super.new(name, parent);\n   endfunction\n\n   extern function void build_phase(uvm_phase phase);\n   extern virtual  task main_phase(uvm_phase phase);\nendclass\n\nfunction void B::build_phase(uvm_phase phase);\n   super.build_phase(phase);\n   B_export = new(\"B_export\", this);\nendfunction\n\ntask B::main_phase(uvm_phase phase);\nendtask\n```\n然后在env将两者进行链接\n```java\nclass my_env extends uvm_env;\n\n   A   A_inst;\n   B   B_inst;\n   \n   \n   function new(string name = \"my_env\", uvm_component parent);\n      super.new(name, parent);\n   endfunction\n\n   virtual function void build_phase(uvm_phase phase);\n      super.build_phase(phase);\n\n      A_inst = A::type_id::create(\"A_inst\", this);\n      B_inst = B::type_id::create(\"B_inst\", this);\n\n   endfunction\n\n   extern virtual function void connect_phase(uvm_phase phase);\n   \n   `uvm_component_utils(my_env)\nendclass\n\nfunction void my_env::connect_phase(uvm_phase phase);\n   super.connect_phase(phase);\n   A_inst.A_port.connect(B_inst.B_export);\nendfunction\n```\n## 2.2 IMP组件\n除了TLM中定义的PORT与EXPORT外，UVM中加入了第三种端口：IMP，起作用相当于在EXPORT后进行接受操作。\n添加IMP后，A的代码变为：\n```java\ntask A::main_phase(uvm_phase phase);\n   my_transaction tr;\n   repeat(10) begin\n      #10;\n      tr = new(\"tr\");\n      assert(tr.randomize());\n      A_port.put(tr);\n   end\nendtask\n```\n在B中需要改动的要多一点：\n```java\nclass B extends uvm_component;\n   `uvm_component_utils(B)\n\n   uvm_blocking_put_export#(my_transaction) B_export;\n   uvm_blocking_put_imp#(my_transaction, B) B_imp;\n   function new(string name, uvm_component parent);\n      super.new(name, parent);\n   endfunction\n\n   extern function void build_phase(uvm_phase phase);\n   extern function void connect_phase(uvm_phase phase);\n   extern function void put(my_transaction tr);\n   extern virtual  task main_phase(uvm_phase phase);\nendclass\n\nfunction void B::build_phase(uvm_phase phase);\n   super.build_phase(phase);\n   B_export = new(\"B_export\", this);\n   B_imp = new(\"B_imp\", this);\nendfunction\n\nfunction void B::connect_phase(uvm_phase phase);\n   super.connect_phase(phase);\n   B_export.connect(B_imp);\nendfunction\n\nfunction void B::put(my_transaction tr);\n   `uvm_info(\"B\", \"receive a transaction\", UVM_LOW) \n   tr.print();\nendfunction\n```\n在上述连接关系中，IMP是作为连接的终点。在UVM中，只有IMP才能作为连接关系的终点。如果是PORT或者EXPORT作为终点，则会报错。\n\n# 三、get操作\nget系列端口与put系列端口在某些方面完全相反。在这种连接关系中，数据流依然是从A到B，但是A由动作发起者变成了动作接收者，而B由动作接收者变成了动作发起者。\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/f21b4b2ebace4ef7b979a76423f57127.png\" height=250 >\n</div>\n\nB_port的类型为uvm_blocking_get_port,A_export的类型为uvm_blocking_get_export,A_imp的类型为uvm_blocking_get_imp。A的代码为：\n```java\nclass A extends uvm_component;\n   `uvm_component_utils(A)\n\n   uvm_blocking_get_export#(my_transaction) A_export;\n   uvm_blocking_get_imp#(my_transaction, A) A_imp;\n   my_transaction tr_q[$];\n   function new(string name, uvm_component parent);\n      super.new(name, parent);\n   endfunction\n\n   extern function void build_phase(uvm_phase phase);\n   extern function void connect_phase(uvm_phase phase);\n   extern virtual  task get(output my_transaction tr);\n   extern virtual  task main_phase(uvm_phase phase);\nendclass\n\nfunction void A::build_phase(uvm_phase phase);\n   super.build_phase(phase);\n   A_export = new(\"A_export\", this);\n   A_imp = new(\"A_imp\", this);\nendfunction\n\nfunction void A::connect_phase(uvm_phase phase);\n   super.connect_phase(phase);\n   A_export.connect(A_imp); \nendfunction\n\ntask A::get(output my_transaction tr);\n   while(tr_q.size() == 0) #2;\n   tr = tr_q.pop_front();\nendtask\n\ntask A::main_phase(uvm_phase phase);\n   my_transaction tr;\n   repeat(10) begin\n      #10;\n      tr = new(\"tr\");\n      tr_q.push_back(tr); \n   end\nendtask\n```\n在A的get任务中，每隔2个时间单位检查tr_q中是否有数据，如果有则发送出去。当B在其main_phase调用get任务时，会最终执行A的get任务。在A的connect_phase，需要把A_export和A_imp连接起来。下面是B的部分：\n```java\nclass B extends uvm_component;\n   `uvm_component_utils(B)\n\n   uvm_blocking_get_port#(my_transaction) B_port;\n   function new(string name, uvm_component parent);\n      super.new(name, parent);\n   endfunction\n\n   extern function void build_phase(uvm_phase phase);\n   extern virtual  task main_phase(uvm_phase phase);\nendclass\n\nfunction void B::build_phase(uvm_phase phase);\n   super.build_phase(phase);\n   B_port = new(\"B_port\", this);\nendfunction\n\ntask B::main_phase(uvm_phase phase);\n   my_transaction tr;\n   while(1) begin\n      B_port.get(tr);\n      `uvm_info(\"B\", \"get a transaction\", UVM_LOW) \n      tr.print();\n   end\nendtask\n```\n在这些连接关系中,需要谨记的是连接的终点必须是一个IMP。\n\n# 四、transport端口\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/338adb1c77e1463ebebd3ca9ee331816.png\" height=250 >\n</div>\n\nA代码如下所示：\n```java\ntask A::main_phase(uvm_phase phase);\n   my_transaction tr;\n   my_transaction rsp;\n   repeat(10) begin\n      #10;\n      tr = new(\"tr\");\n      assert(tr.randomize());\n      A_transport.transport(tr, rsp);\n      `uvm_info(\"A\", \"received rsp\", UVM_MEDIUM)\n      rsp.print();\n   end\nendtask\n```\nB中需要定义一个类型为uvm_blocking_transport_imp的IMP：\n```java\nclass B extends uvm_component;\n   `uvm_component_utils(B)\n\n   uvm_blocking_transport_imp#(my_transaction, my_transaction, B) B_imp;\n   function new(string name, uvm_component parent);\n      super.new(name, parent);\n   endfunction\n\n   extern function void build_phase(uvm_phase phase);\n   extern task transport(my_transaction req, output my_transaction rsp);\nendclass\n\nfunction void B::build_phase(uvm_phase phase);\n   super.build_phase(phase);\n   B_imp = new(\"B_imp\", this);\nendfunction\n\ntask B::transport(my_transaction req, output my_transaction rsp);\n   `uvm_info(\"B\", \"receive a transaction\", UVM_LOW) \n   req.print();\n   //do something according to req\n   #5;\n   rsp = new(\"rsp\");\nendtask\n```\nenv中的代码是：\n```java\nfunction void my_env::connect_phase(uvm_phase phase);\n   super.connect_phase(phase);\n   A_inst.A_transport.connect(B_inst.B_imp);\nendfunction\n```\n在A中调用transport任务，并把生成的transaction作为第一个参数。B中的transaport任务接收到这笔transaction，根据这笔transaction做某些操作，并把操作的结果作为transport的第二个参数发送出去。A根据接收到的rsp来决定后面的行为。\n# 五、nonblocking端口\n```java\ntask A::main_phase(uvm_phase phase);\n   my_transaction tr;\n   repeat(10) begin\n      tr = new(\"tr\");\n      assert(tr.randomize());\n      while(!A_port.can_put()) #10;\n      void'(A_port.try_put(tr));\n   end\nendtask\n```\n由于端口变为了非阻塞的，所以在送出transaction之前需要调用can_put函数来确认是否能够执行put操作。can_put最终会调用B中的can_put:\n\n# 六、analysis端口\nUVM中还有两种特殊的端口：analysis_port和analysis_export。该端口有两点需要注意的地方：\n- 一个analysis_port(analysis_export)可以连接多个IMP，analysis_port(analysis_export)与IMP  之间的通信是一对多的通信。analysis_port(analysis_export)更像是一个广播。\n- put与get系列端口都有阻塞和非阻塞的区分。但是对于analysis_port和analysis_export来说,没有阻塞和非阻塞的概念。\n\n一个analysis_port可以和多个IMP相连接进行通信，但是IMP的类型必须是uvm_analysis_imp,否则会报错。\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/cfeed375eb6d4d189425c5d4cbbf34a5.png\" height=250 >\n</div>\n\n下面是A的代码：\n```java\nclass A extends uvm_component;\n   `uvm_component_utils(A)\n\n   uvm_analysis_port#(my_transaction) A_ap;\n   function new(string name, uvm_component parent);\n      super.new(name, parent);\n   endfunction\n\n   extern function void build_phase(uvm_phase phase);\n   extern virtual  task main_phase(uvm_phase phase);\nendclass\n\nfunction void A::build_phase(uvm_phase phase);\n   super.build_phase(phase);\n   A_ap = new(\"A_ap\", this);\nendfunction\n\ntask A::main_phase(uvm_phase phase);\n   my_transaction tr;\n   repeat(10) begin\n      #10;\n      tr = new(\"tr\");\n      assert(tr.randomize());\n      A_ap.write(tr);\n   end\nendtask\n```\nA的代码很简单，只是简单地定义一个analysis_port，并在main_phase中每隔10个时间单位写入一个transaction。\nB的代码为：\n```java\nfunction void B::write(my_transaction tr);\n   `uvm_info(\"B\", \"receive a transaction\", UVM_LOW) \n   tr.print();\nendfunction\n```\n在env中通过下面方式进行连接：\n```java\nfunction void my_env::connect_phase(uvm_phase phase);\n   super.connect_phase(phase);\n   A_inst.A_ap.connect(B_inst.B_imp);\n   A_inst.A_ap.connect(C_inst.C_imp);\nendfunction\n```\n上面只是一个analysis_port与IMP相连的例子。analysis_export和IMP也可以这样相连接,只需将上面例子中的uvm_analysis_port改为uvm_analysis_export就可以。\n\n# 七、monitor与scoreboard之间的通信\n和上一个一样，在两段分别进行定义，monitor的代码为：\n```java\ntask my_monitor::main_phase(uvm_phase phase);\n   my_transaction tr;\n   while(1) begin\n      tr = new(\"tr\");\n      collect_one_pkt(tr);\n      ap.write(tr);\n   end\nendtask\n```\nscoreboard的代码为：\n```java\nfunction void my_scoreboard::write_monitor(my_transaction tr);\n   my_transaction  tmp_tran;\n   bit result;\n   if(expect_queue.size() > 0) begin\n      tmp_tran = expect_queue.pop_front();\n      result = tr.compare(tmp_tran);\n      if(result) begin \n         `uvm_info(\"my_scoreboard\", \"Compare SUCCESSFULLY\", UVM_LOW);\n      end\n      else begin\n         `uvm_error(\"my_scoreboard\", \"Compare FAILED\");\n         $display(\"the expect pkt is\");\n         tmp_tran.print();\n         $display(\"the actual pkt is\");\n         tr.print();\n      end\n   end\n   else begin\n      `uvm_error(\"my_scoreboard\", \"Received from DUT, while Expect Queue is empty\");\n      $display(\"the unexpected pkt is\");\n      tr.print();\n   end\nendfunction\n```\n之后在env中可以使用connect连接。\n由于monitor与scoreboard在UVM树中并不是平等的兄妹关系，这里选择下面的连接方式：\n在agent中声明一个ap,但是不实例化它,让其指向monitor中的ap。在env中可以直接连接agent的ap到scoreboard的imp：\n```java\nagent:\nclass my_agent extends uvm_agent ; \n\tuvm_analysis_port #(my_transaction) ap; \n\t...  \n\tfunction void my_agent::connect_phase(uvm_phase phase); \n\t\tap = mon.ap; \n\t\t...  \n\tendfunction \nendclass \nenv:\nfunction void my_env::connect_phase(uvm_phase phase); \n\to_agt.ap.connect(scb.scb_imp); \n\t\t...  \nendfunction\n```\n在上面的例子中，scoreboard只接收一路数据。但在现实情况中，scoreboard除了接收monitor的数据之外，还要接收reference model的数据。相应的scoreboard就要再添加一个  uvm_analysis_imp的IMP。此时问题就出现了，由于接收到的两路数据应该做不同的处理，所以这个新的IMP也要有一个write任务与其对应。但是write只有一个，怎么办?\n可以使用宏定义的方法：\n```java\n`uvm_analysis_imp_decl(_monitor)\n`uvm_analysis_imp_decl(_model)\nclass my_scoreboard extends uvm_scoreboard;\n   \tmy_transaction  expect_queue[$];\n\tuvm_analysis_imp_monitor#(my_transaction, my_scoreboard) monitor_imp; \n\tuvm_analysis_imp_model#(my_transaction, my_scoreboard) model_imp;\n   `uvm_component_utils(my_scoreboard)\n\n   extern function new(string name, uvm_component parent = null);\n   extern virtual function void build_phase(uvm_phase phase);\n   extern virtual task main_phase(uvm_phase phase);\nendclass \n```\n上述代码通过宏uvm_analysis_imp_decl声明了两个后缀_monitor和_model。\n当与monitor_imp相连接的analysis_port执行write函数时,会自动调用write_monitor函数,而与model_imp相连接的analysis_port执行write  函数时,会自动调用write_model函数。\n\n# 八、使用FIFO通信\n使用fifo的方法能够让两个端口都能实现主动的接收，因此下面的例子便是利用FIFO来实现monitor和scoreboard的通信。\nFIFO的本质是一块缓存加两个IMP。在monitor与FIFO的连接关系中，monitor中依然是analysis_port，FIFO中是uvm_analysis_imp，数据流和控制流的方向相同。在scoreboard与FIFO的连接关系中，scoreboard中使用blocking_get_port端口：\n```\nclass my_scoreboard extends uvm_scoreboard;\n   my_transaction  expect_queue[$];\n   uvm_blocking_get_port #(my_transaction)  exp_port[16];\n   uvm_blocking_get_port #(my_transaction)  act_port;\n   `uvm_component_utils(my_scoreboard)\n\n   extern function new(string name, uvm_component parent = null);\n   extern virtual function void build_phase(uvm_phase phase);\n   extern virtual task main_phase(uvm_phase phase);\nendclass \n```\n而FIFO中使用的是一个get端口的IMP。在这种连接关系中，控制流是从scoreboard到FIFO，而数据流是从FIFO到scoreboard。\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/597c97f211e7411cad212a6b0083aa55.png\" height=300 >\n</div>\n\n在env中连接方式如下：\n```\nfunction void my_env::connect_phase(uvm_phase phase);\n   super.connect_phase(phase);\n   i_agt.ap.connect(agt_mdl_fifo.analysis_export);\n   mdl.port.connect(agt_mdl_fifo.blocking_get_export);\n   for(int i = 0; i < 16; i++) begin\n      mdl.ap[i].connect(mdl_scb_fifo[i].analysis_export);\n      scb.exp_port[i].connect(mdl_scb_fifo[i].blocking_get_export);\n   end\n   o_agt.ap.connect(agt_scb_fifo.analysis_export);\n   scb.act_port.connect(agt_scb_fifo.blocking_get_export); \nendfunction\n```\nFIFO中有两个IMP，但是在上面的连接关系中，FIFO中却是EXPORT，这是为什么呢？实际上，FIFO中的analysis_export和blocking_get_export虽然名字中有关键字export，但是其类型却是IMP。UVM为了掩饰IMP的存在，在它们的命名中加入了export关键字。\n但事实上，FIFO上的端口并不局限于上述两个，一个FIFO中有众多的端口。端口列表如下：\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/695c20087ecb4cd998290857b6774ac3.png\" height=300 >\n</div>\n\n# 总结\n总结来说，这一章主要讲了数据在UVM中的传递方式，学习这一章可以更好的编写灵活性更高的UVM代码。\n","tags":["UVM"],"categories":["UVM学习笔记"]},{"title":"【UVM学习笔记】UVM基础—一文告诉你UVM的组成部分","url":"/2025/04/16/675312ec1441/","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n---\n\n# 一、Driver驱动器\n这段代码是用 SystemVerilog 编写的一个基于 UVM（Universal Verification Methodology）的驱动器（driver）组件，名为 my_driver。它继承自 uvm_driver 类，用于在验证环境中驱动 DUT（Design Under Test，被测设计）的输入信号。下面我将逐步解释这段代码的结构和功能。\n\n## 1.1 整体结构\n代码分为两个主要部分：\n- 类定义部分：定义了 my_driver 类，包括构造函数和一个外部声明的任务（main_phase）。\n- 任务实现部分：实现了 main_phase 任务，负责具体的信号驱动逻辑。\n\n此外，代码使用 ifndef 和 define 宏来防止重复包含。\n\n## 1.2 详细解释\n### 1.2.1 宏定义保护\n```java\nifndef MY_DRIVER__SV\ndefine MY_DRIVER__SV\n```\n检查是否已经定义了宏MY_DRIVER__SV。如果没有定义，则编译器会继续处理后面的代码。\n最后，文件末尾的 endif 与开头的 ifndef 配对，结束条件编译块。\n\n### 1.2.2 类定义\n```java\nclass my_driver extends uvm_driver;\n   function new(string name = \"my_driver\", uvm_component parent = null);\n      super.new(name, parent);\n   endfunction\n   extern virtual task main_phase(uvm_phase phase);\nendclass\n```\nclass my_driver extends uvm_driver：定义一个名为 my_driver 的类，并且表示 my_driver 继承自 UVM 提供的基类 uvm_driver。\nuvm_driver 是 UVM 框架中的一个标准组件类，用于将事务级数据转换为 DUT 的引脚级信号。\n>事务级数据是指更高层次的抽象数据，通常以结构体或类的形式表示，而不是直接的硬件信号（0 和 1）。它描述的是“做什么”，而不是“怎么做”。\n>假设事务是一个 8 位数据 8'b10100101。\n驱动器将其转换为：\ntop_tb.rxd <= 8'b10100101;（数据信号）\ntop_tb.rx_dv <= 1'b1;（有效信号）\n并在 @(posedge top_tb.clk) 时更新这些信号。\n\n\n`function new`：定义类的构造函数，用于创建 my_driver 对象。\n`super.new(name, parent)`：调用父类 uvm_driver 的构造函数，将 name 和 parent 参数传递给它。这是 UVM 中面向对象编程的标准做法，确保父类的初始化逻辑被执行。\n`extern`：表示 main_phase 任务的实现不在类定义内部，而是在外部单独定义。\n`virtual`：声明这是一个虚任务，允许子类重写（override）它。这是 UVM 中 phase 方法的常见做法。\n`task main_phase(uvm_phase phase)`：定义一个名为 main_phase 的任务，接收一个 uvm_phase 类型的参数 phase，表示 UVM 的仿真阶段（这里是 main_phase，通常用于主要的测试执行阶段）。\n\n### 1.2.3 任务实现\n```java\ntask my_driver::main_phase(uvm_phase phase);\n   top_tb.rxd <= 8'b0;\n   top_tb.rx_dv <= 1'b0;\n   while(!top_tb.rst_n)\n      @(posedge top_tb.clk);\n   for(int i = 0; i < 256; i++)begin\n      @(posedge top_tb.clk);\n      top_tb.rxd <= $urandom_range(0, 255);\n      top_tb.rx_dv <= 1'b1;\n      `uvm_info(\"my_driver\", \"data is drived\", UVM_LOW)\n   end\n   @(posedge top_tb.clk);\n   top_tb.rx_dv <= 1'b0;\nendtask\n```\n`my_driver::main_phase`：明确指定这个任务是 my_driver 类的一部分。\n这是 main_phase 的具体实现，负责驱动 DUT 的信号。\nuvm_info(\"my_driver\", \"data is drived\", UVM_LOW)：\nUVM 提供的日志记录宏，打印信息。\n`my_driver`：消息来源（组件名）。\n`data is drived`：消息内容。\n`UVM_LOW`：日志级别，表示低详细程度。\n作用：在 256 个时钟周期内，连续向 DUT 的 rxd 输入随机数据，并将 rx_dv 置为 1，同时记录日志。\n\n> 所谓类的定义,就是用编辑器写下：\n> ```java\n>class A\n>...\n>endclass\n>```\n>而所谓类的实例化指的是通过new创造出A的一个实例:\n>```java\n>A a_list;\n>a_list = new();\n>```\n\n\n### 1.2.4 factory机制\nfactory机制的实现被集成在了一个宏中：uvm_component_utils。这个宏所做的事情非常多，其中之一就是将my_driver登记在UVM内部的一张表中，这张表是 factory 功能实现的基础。只要在定义一个新的类时使用这个宏，就相当于把这个类注册到了这张表中。\n```java\n`uvm_component_utils(my_driver)\n```\n在给driver中加入factory机制后，还需要对top_tb做一些改动：\n```java\ninitial begin\n\trun_test(\"my_driver\");\nend\n```\n但是输出的结果只有两个，没有执行后面的代码，关于这个问题，牵涉UVM的objection机制。\n```java\nUVM_INFO my_driver.sv(8) @ 0: uvm_test_top [my_driver] new is called\nUVM_INFO @ 0: reporter [RNTST] Running test my_driver...\nUVM_INFO my_driver.sv(14) @ 0: uvm_test_top [my_driver] main_phase is called\n```\n### 1.2.4 objection机制\nUVM中通过objection机制来控制验证平台的关闭。细心的读者可能发现，在上节的例子中，并没有如2.2.1节所示显式地调用 finish 语句来结束仿真。但是在运行上节例子时，仿真平台确实关闭了。在每个phase中，UVM会检查是否有objection被提起  (raise_objection)，如果有，那么等待这个objection被撤销(drop_objection)后停止仿真；如果没有，则马上结束当前 phase。\n```java\ntask my_driver::main_phase(uvm_phase phase);\n   phase.raise_objection(this);\n\t...\n   phase.drop_objection(this);\nendtask\n```\nraise_objection语句必须在main_phase中第一个消耗仿真时间的语句之前。\t\n### 1.2.5 加入virtual interface\n\n使用该方法能够杜绝因为绝对路径所带来的不便，在SystemVerilog中使用interface来连接验证平台与DUT的端口，该端口可以认为是一种总线。\n定义interface的方法如下：\n```java\n`ifndef MY_IF__SV\n`define MY_IF__SV\n\ninterface my_if(input clk, input rst_n);\n   logic [7:0] data;\n   logic valid;\nendinterface\n\n`endif\n```\n因为my_driver是一个类，在类中不能使用声明的方法定义一个  interface，只有在类似top_tb这样的模块(module)中才可以。在类中使用的是virtual interface：\n```java\nvirtual my_if vif;\n```\n因此在 中就可以使用该方法来使用：\n```java\ntask my_driver::main_phase(uvm_phase phase);\n   phase.raise_objection(this);\n   `uvm_info(\"my_driver\", \"main_phase is called\", UVM_LOW);\n   vif.data <= 8'b0; \n   vif.valid <= 1'b0;\n   while(!vif.rst_n)\n      @(posedge vif.clk);\n   for(int i = 0; i < 256; i++)begin\n      @(posedge vif.clk);\n      vif.data <= $urandom_range(0, 255);\n      vif.valid <= 1'b1;\n      `uvm_info(\"my_driver\", \"data is drived\", UVM_LOW);\n   end\n   @(posedge vif.clk);\n   vif.valid <= 1'b0;\n   phase.drop_objection(this);\nendtask\n```\n下面的问题是，如何把top_tb中的input_if和my_driver中的vif对应起来。\n针对该问题，UVM引进了config_db机制。在config_db机制中，分为set和get两步操作。set就是读取数据，get就是输出数据。在top_tb中的代码如下所示：\n```java\ninitial begin\n   uvm_config_db#(virtual my_if)::set(null, \"uvm_test_top\", \"vif\", input_if);\nend\n```\n在my_driver中的代码如下所示：\n```java\n   virtual function void build_phase(uvm_phase phase);\n      super.build_phase(phase);\n      `uvm_info(\"my_driver\", \"build_phase is called\", UVM_LOW);\n      if(!uvm_config_db#(virtual my_if)::get(this, \"\", \"vif\", vif))\n         `uvm_fatal(\"my_driver\", \"virtual interface must be set for vif!!!\")\n   endfunction\n```\n首先build_phase也是内置函数，build_phase在new函数之后main_phase之前执行。其中的super.build_phase语句是因为在其父类的build_phase中执行了一些必要的操作。\n其中还出现了uvm_fatal宏，其与uvm_info的作用类似。uvm_fatal的出现表示验证平台出现了重大问题而无法继续下去,必须停止仿真并做相应的检查。\nconfig_db的set和get函数都有四个参数，这两个函数的第三个参数必须完全一致。\n- set函数的第四个参数表示要将哪个interface通过config_db传递给my_driver\n- get函数的第四个参数表示把得到的interface传递给哪个my_driver的成员变量。\n\nset函数的第二个参数表示的是路径索引，UVM通过run_test语句创建一个名字为uvm_test_top的实例，因此需要输入uvm_test_top。无论传递给run_test的参数是什么,创建的实例的名字都为uvm_test_top。其他两个参数以后再说。\nset函数与get函数使用双冒号是因为这两个函数都是静态函数，而前面的#键是要传递的类型,这里是virtual my_if。\n# 二、transaction组件\ntransaction就是一个提供数据传输的打包操作。在不同的验证平台中,会有不同的transaction。一个简单的transaction的定义如下:\n```java\n`ifndef MY_TRANSACTION__SV\n`define MY_TRANSACTION__SV\n\nclass my_transaction extends uvm_sequence_item;\n\n   rand bit[47:0] dmac;\n   rand bit[47:0] smac;\n   rand bit[15:0] ether_type;\n   rand byte      pload[];\n   rand bit[31:0] crc;\n\n   constraint pload_cons{\n      pload.size >= 46;\n      pload.size <= 1500;\n   }\n\n   function bit[31:0] calc_crc();\n      return 32'h0;\n   endfunction\n\n   function void post_randomize();\n      crc = calc_crc;\n   endfunction\n\n   `uvm_object_utils(my_transaction)\n\n   function new(string name = \"my_transaction\");\n      super.new();\n   endfunction\nendclass\n`endif\n```\n其中dmac和smac模拟的就是发送地址和接受地址，ether_type是以太网类型，pload是其携带数据的大小。下面的函数是用于约束上述数据的。通过pload_cons约束将其大小被限制在46~1500byte，CRC暂且使用post_randomize中加的一个空函数calc_crc来对其定义，有兴趣的读者可以将其补充完整。\n>post_randomize是SystemVerilog中提供的一个函数，当某个类的实例的randomize函数被调用后,post_randomize会紧随其后无条件地被调用。\n\n在transaction定义中，有两点值得引起注意：\n1. my_transaction的基类是uvm_sequence_item。\n在UVM中,所有的transaction都要从uvm_sequence_item派生\n2. 是这里没有使用uvm_component_utils宏来实现factory机制，而是使用了uvm_object_utils。\n\n下面便是使用transaction的my_driver代码：\n```java\ntask my_driver::main_phase(uvm_phase phase);\n   my_transaction tr;\n   phase.raise_objection(this);\n   vif.data <= 8'b0;\n   vif.valid <= 1'b0;\n   while(!vif.rst_n)\n      @(posedge vif.clk);\n   for(int i = 0; i < 2; i++) begin \n      tr = new(\"tr\");\n      assert(tr.randomize() with {pload.size == 200;});\n      drive_one_pkt(tr);\n   end\n   repeat(5) @(posedge vif.clk);\n   phase.drop_objection(this);\nendtask\n\ntask my_driver::drive_one_pkt(my_transaction tr);\n   bit [47:0] tmp_data;\n   bit [7:0] data_q[$]; \n  \n   //push dmac to data_q\n   tmp_data = tr.dmac;\n   for(int i = 0; i < 6; i++) begin\n      data_q.push_back(tmp_data[7:0]);\n      tmp_data = (tmp_data >> 8);\n   end\n   //push smac to data_q\n   //push ether_type to data_q\n   //push payload to data_q\n   //push crc to data_q\n\n   `uvm_info(\"my_driver\", \"begin to drive one pkt\", UVM_LOW);\n   repeat(3) @(posedge vif.clk);\n\n   while(data_q.size() > 0) begin\n      @(posedge vif.clk);\n      vif.valid <= 1'b1;\n      vif.data <= data_q.pop_front(); \n   end\n\n   @(posedge vif.clk);\n   vif.valid <= 1'b0;\n   `uvm_info(\"my_driver\", \"end drive one pkt\", UVM_LOW);\nendtask\n```\n在main_phase中，先使用randomize将tr随机化，之后通过drive_one_pkt任务将tr的内容驱动到DUT的端口上。\n在drive_one_pkt中，先将tr中所有的数据压入队列data_q中，之后再将data_q中所有的数据弹出输入到DUT端口上。\n# 三、env组件\n为了能够更好的实例化my_dirver等组件，需要有一个容器去把他们装在一起，这个容器就是env，代码如下：\n```java\n`ifndef MY_ENV__SV\n`define MY_ENV__SV\n\nclass my_env extends uvm_env;\n\n   my_driver drv;\n\n   function new(string name = \"my_env\", uvm_component parent);\n      super.new(name, parent);\n   endfunction\n\n   virtual function void build_phase(uvm_phase phase);\n      super.build_phase(phase);\n      drv = my_driver::type_id::create(\"drv\", this); \n   endfunction\n\n   `uvm_component_utils(my_env)\nendclass\n`endif\n```\n在my_env的定义中，使用了区别于new的方式，只有使用这种方式实例化的实例，验证平台中的组件在实例化时都应该使用type_name::type_id::create的方式。\n回顾一下my_driver的new函数：\n```java\nfunction new(string name = \"my_driver\", uvm_component parent = null); \n\tsuper.new(name, parent); \nendfuncti\n```\n可以看出 my_driver 的父结点就是my_env。通过parent的形式，UVM建立起了树形的组织结构。在这种树形的组织结构中，由run_test创建的实例是树根，并且树根的名字是固定的为uvm_test_top，长出枝叶的过程需要在my_env的build_phase中手动实现。\n无论是树根还是树叶，都必须由 uvm_component 或者其派生类继承而来。整棵UVM树的结构如图所示。\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/2e7b6a7f3cf44aebacd2edf67b18d061.png\" height=250>\n</div>\n在UVM的树形结构中，build_phase的执行遵照从树根到树叶的顺序。\n在top_tb中使用config_db机制传递virtual  my_if时，要改变相应的路径；同时，run_test的参数也从my_driver变为了my_env。\n```java\ninitial begin\n   run_test(\"my_env\");\nend\n\ninitial begin\n   uvm_config_db#(virtual my_if)::set(null, \"uvm_test_top.drv\", \"vif\", input_if);\nend\n```\nset函数的第二个参数从uvm_test_top变为了uvm_test_top.drv，其中uvm_test_top是UVM自动创建的树根的名字，而drv则是在my_env的build_phase中实例化drv时传递过去的名字。\n# 四、monitor组件\n验证平台中实现监测DUT行为的组件是monitor，其主要功能起到一个监测作用。其将用于收集DUT的端口数据，并将其转换成transaction交给后续的组件处理。代码如下：\n```java\n`ifndef MY_MONITOR__SV\n`define MY_MONITOR__SV\nclass my_monitor extends uvm_monitor;\n   virtual my_if vif;\n   `uvm_component_utils(my_monitor)\n   function new(string name = \"my_monitor\", uvm_component parent = null);\n      super.new(name, parent);\n   endfunction\n   virtual function void build_phase(uvm_phase phase);\n      super.build_phase(phase);\n      if(!uvm_config_db#(virtual my_if)::get(this, \"\", \"vif\", vif))\n         `uvm_fatal(\"my_monitor\", \"virtual interface must be set for vif!!!\")\n   endfunction\n   extern task main_phase(uvm_phase phase);\n   extern task collect_one_pkt(my_transaction tr);\nendclass\ntask my_monitor::main_phase(uvm_phase phase);\n   my_transaction tr;\n   while(1) begin\n      tr = new(\"tr\");\n      collect_one_pkt(tr);\n   end\nendtask\ntask my_monitor::collect_one_pkt(my_transaction tr);\n   bit[7:0] data_q[$]; \n   int psize;\n   while(1) begin\n      @(posedge vif.clk);\n      if(vif.valid) break;\n   end\n   `uvm_info(\"my_monitor\", \"begin to collect one pkt\", UVM_LOW);\n   while(vif.valid) begin\n      data_q.push_back(vif.data);\n      @(posedge vif.clk);\n   end\n   //pop dmac\n   //pop smac\n   //pop ether_type\n   //pop payload\n   //pop crc\n   `uvm_info(\"my_monitor\", \"end collect one pkt, print it:\", UVM_LOW);\n    tr.my_print();\nendtask\n`endif\n```\n该代码与my_driver非常相似。其主要工作与my_driver相反，my_driver用于产生驱动信号，而该模块则用于收集。\n最后要在evn中进行实例化：\n```java\n   virtual function void build_phase(uvm_phase phase);\n      super.build_phase(phase);\n      drv = my_driver::type_id::create(\"drv\", this); \n      i_mon = my_monitor::type_id::create(\"i_mon\", this);\n      o_mon = my_monitor::type_id::create(\"o_mon\", this);\n   endfunction\n```\n需要注意的是这里定义了两个my_monitor模块，一个收集输入的，另一个收集输出的。树形结构如下所示：\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/6a95bda1540841519687a48c87f6b982.png\" height=250 >\n</div>\n\n# 五、agent组件\n因为my_monitor和my_dirver有相似性，因此可以将两者封装在一起，使用agent组件，代码如下：\n```java\n`ifndef MY_AGENT__SV\n`define MY_AGENT__SV\n\nclass my_agent extends uvm_agent ;\n   my_driver     drv;\n   my_monitor    mon;\n   \n   function new(string name, uvm_component parent);\n      super.new(name, parent);\n   endfunction \n   \n   extern virtual function void build_phase(uvm_phase phase);\n   extern virtual function void connect_phase(uvm_phase phase);\n\n   `uvm_component_utils(my_agent)\nendclass \n\nfunction void my_agent::build_phase(uvm_phase phase);\n   super.build_phase(phase);\n   if (is_active == UVM_ACTIVE) begin\n       drv = my_driver::type_id::create(\"drv\", this);\n   end\n   mon = my_monitor::type_id::create(\"mon\", this);\nendfunction \n\nfunction void my_agent::connect_phase(uvm_phase phase);\n   super.connect_phase(phase);\nendfunction\n`endif\n```\n> 这里有一点比较疑惑，为什么build_phase和connect_phase要在外面定义？为什么不在里面？\n\n里面的is_active相当于一个宏定义，用于判断是否实例化dirver，比如再输入的时候需要实例化去驱动，但是在输出就不需要。因此，env的代码就变成下面的样子：\n```java\n   virtual function void build_phase(uvm_phase phase);\n      super.build_phase(phase);\n      i_agt = my_agent::type_id::create(\"i_agt\", this);\n      o_agt = my_agent::type_id::create(\"o_agt\", this);\n      i_agt.is_active = UVM_ACTIVE;\n      o_agt.is_active = UVM_PASSIVE;\n   endfunction\n```\nUVM_ACTIVE和UVM_PASSIVE是两个枚举。UVM树形结构变成下面这样：\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/dca1a8311f1645eea8269ee8d46ad625.png\" height=250 >\n</div>\n\n# 五、reference model组件\nreference model用于完成和DUT相同的功能，用于与设计的验证平台在后面的计分板上做对比。改模块的代码如下所示：\n```java\n`ifndef MY_MODEL__SV\n`define MY_MODEL__SV\n\nclass my_model extends uvm_component;\n   \n   uvm_blocking_get_port #(my_transaction)  port;\n   uvm_analysis_port #(my_transaction)  ap;\n\n   extern function new(string name, uvm_component parent);\n   extern function void build_phase(uvm_phase phase);\n   extern virtual  task main_phase(uvm_phase phase);\n\n   `uvm_component_utils(my_model)\nendclass \n\nfunction my_model::new(string name, uvm_component parent);\n   super.new(name, parent);\nendfunction \n\nfunction void my_model::build_phase(uvm_phase phase);\n   super.build_phase(phase);\n   port = new(\"port\", this);\n   ap = new(\"ap\", this);\nendfunction\n\ntask my_model::main_phase(uvm_phase phase);\n   my_transaction tr;\n   my_transaction new_tr;\n   super.main_phase(phase);\n   while(1) begin\n      port.get(tr);\n      new_tr = new(\"new_tr\");\n      new_tr.my_copy(tr);\n      `uvm_info(\"my_model\", \"get one transaction, copy and print it:\", UVM_LOW)\n      new_tr.my_print();\n      ap.write(new_tr);\n   end\nendtask\n`endif\n```\n可以看出，其主要就是复制了一份tr从ap到port。\n但是其中的难点在于如何将 my_model 与其他模块进行通信。在UVM中,通常使用TLM(Transaction Level Modeling)实现component之间transaction级别  的通信。得到的UVM树形图如下所示：\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/34cc566007d74a9bab7dae60f0c05ca3.png\" height=250 >\n</div>\n\n这里需要注意数据流动的方向，是从i_agt流动到mdl，而数据是i_agt中的my_monitor。因此在 my_monitor 需要定义一下：\n```java\nuvm_analysis_port #(my_transaction)  ap;\n   virtual function void build_phase(uvm_phase phase);\n...\n      ap = new(\"ap\", this);\n   endfunction\n   \ntask my_monitor::main_phase(uvm_phase phase);\n   my_transaction tr;\n   while(1) begin\n      tr = new(\"tr\");\n      collect_one_pkt(tr);\n      ap.write(tr);\n   end\nendtask\n```\nuvm_analysis_port是一个参数化的类，其参数就是这个analysis_port需要传递的数据的类型,在本节中是my_transaction。到此,在my_monitor中需要为transaction通信准备的工作已经全部完成。\nUVM的transaction级别通信的数据接收方式也有多种,其中一种就是使用uvm_blocking_get_port。该接收端已经在 my_monitor 中定义好了。可以往前去看my_monitor的代码。\n在 my_monitor 和 my_model 中定义并实现了各自的端口之后，通信的功能并没有实现,还需要在 my_env 中使用 fifo 将两个端口联系在一起。下面是my_env 中的代码：\n```java\nclass my_env extends uvm_env;\n   uvm_tlm_analysis_fifo #(my_transaction) agt_mdl_fifo;\n...\n   virtual function void build_phase(uvm_phase phase);\n   ...\n      agt_mdl_fifo = new(\"agt_mdl_fifo\", this);\n   endfunction\n...\nendclass\n\nfunction void my_env::connect_phase(uvm_phase phase);\n   super.connect_phase(phase);\n   i_agt.ap.connect(agt_mdl_fifo.analysis_export);\n   mdl.port.connect(agt_mdl_fifo.blocking_get_export);\nendfunction\n\n`endif\n```java\nfifo的类型是uvm_tlm_analysis_fifo，其参数是存储在其中的transaction的类型。\n>这里引入了connect_phase。它的执行顺序并不是从树根到树叶,而是从树叶到树根——先执行driver和  monitor的connect_phase,再执行agent的connect_phase,最后执行env的connect_phase。\n\n但是该连接是与i_agt进行连接，怎么打通i_agt与my_monitor之间的通道呢？就是使用指针的方式。i_agt中的代码如下：\n```java\nuvm_analysis_port #(my_transaction)  ap;\nfunction void my_agent::connect_phase(uvm_phase phase);\n   super.connect_phase(phase);\n   ap = mon.ap;\nendfunction\n```\n在这个代码里面没有实例化，直接将mon中的ap传给i_agt中的ap，就是用指针的形式，在访问i_agt中的ap时等价于访问mon中的ap。\n# 六、scoreboard组件\n该模块的作用就是比较DUT以及镜像模块的输出数值。代码如下：\n```java\n`ifndef MY_SCOREBOARD__SV\n`define MY_SCOREBOARD__SV\nclass my_scoreboard extends uvm_scoreboard;\n   my_transaction  expect_queue[$];\n   uvm_blocking_get_port #(my_transaction)  exp_port;\n   uvm_blocking_get_port #(my_transaction)  act_port;\n   `uvm_component_utils(my_scoreboard)\n\n   extern function new(string name, uvm_component parent = null);\n   extern virtual function void build_phase(uvm_phase phase);\n   extern virtual task main_phase(uvm_phase phase);\nendclass \n\nfunction my_scoreboard::new(string name, uvm_component parent = null);\n   super.new(name, parent);\nendfunction \n\nfunction void my_scoreboard::build_phase(uvm_phase phase);\n   super.build_phase(phase);\n   exp_port = new(\"exp_port\", this);\n   act_port = new(\"act_port\", this);\nendfunction \n\ntask my_scoreboard::main_phase(uvm_phase phase);\n   my_transaction  get_expect,  get_actual, tmp_tran;\n   bit result;\n \n   super.main_phase(phase);\n   fork \n      while (1) begin\n         exp_port.get(get_expect);\n         expect_queue.push_back(get_expect);\n      end\n      while (1) begin\n         act_port.get(get_actual);\n         if(expect_queue.size() > 0) begin\n            tmp_tran = expect_queue.pop_front();\n            result = get_actual.my_compare(tmp_tran);\n            if(result) begin \n               `uvm_info(\"my_scoreboard\", \"Compare SUCCESSFULLY\", UVM_LOW);\n            end\n            else begin\n               `uvm_error(\"my_scoreboard\", \"Compare FAILED\");\n               $display(\"the expect pkt is\");\n               tmp_tran.my_print();\n               $display(\"the actual pkt is\");\n               get_actual.my_print();\n            end\n         end\n         else begin\n            `uvm_error(\"my_scoreboard\", \"Received from DUT, while Expect Queue is empty\");\n            $display(\"the unexpected pkt is\");\n            get_actual.my_print();\n         end \n      end\n   join\nendtask\n`endif\n```\nmy_scoreboard需要比较两种数据，前者通过exp_port获取，而后者通过  act_port获取。在main_phase中通过fork建立起了两个进程：\n- 一个进程处理exp_port的数据，当收到数据后，把数据放入expect_queue中。\n- 另外一个进程处理act_port的数据，这是DUT的输出数据，当收集到这些数据后，将参考数据从队列里面弹出，并调用my_transaction的my_compare函数。\n\n最终的UVM树形图如下所示：\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/2dfa4430c5194be0a118044882f3b675.png\" height=250 >\n</div>\n\nmy_transaction的my_compare函数很简单，代码如下所示：\n```java\n   function bit my_compare(my_transaction tr);\n      bit result;\n      \n      if(tr == null)\n         `uvm_fatal(\"my_transaction\", \"tr is null!!!!\")\n      result = ((dmac == tr.dmac) &&\n                (smac == tr.smac) &&\n                (ether_type == tr.ether_type) &&\n                (crc == tr.crc));\n      if(pload.size() != tr.pload.size())\n         result = 0;\n      else \n         for(int i = 0; i < pload.size(); i++) begin\n            if(pload[i] != tr.pload[i])\n               result = 0;\n         end\n      return result; \n   endfunction\n```\n还有两个端口与外界的连接，在书里表示不在过多赘述，这里我简单说一下：首先有两个连接，一个是o_agt的数据，还有一个是my_model中的镜像数据，两者的输入接口都使用`uvm_analysis_port #(my_transaction)  ap;`来定义。因此在本组件中`uvm_blocking_get_port`定义接受，连接代码如下：\n```java\n   uvm_tlm_analysis_fifo #(my_transaction) agt_scb_fifo;\n   uvm_tlm_analysis_fifo #(my_transaction) agt_mdl_fifo;\n   uvm_tlm_analysis_fifo #(my_transaction) mdl_scb_fifo;\n\nfunction void my_env::connect_phase(uvm_phase phase);\n   super.connect_phase(phase);\n   i_agt.ap.connect(agt_mdl_fifo.analysis_export);\n   mdl.port.connect(agt_mdl_fifo.blocking_get_export);\n   mdl.ap.connect(mdl_scb_fifo.analysis_export);\n   scb.exp_port.connect(mdl_scb_fifo.blocking_get_export);\n   o_agt.ap.connect(agt_scb_fifo.analysis_export);\n   scb.act_port.connect(agt_scb_fifo.blocking_get_export); \nendfunction\n```\n# 七、field_automation机制\n在my_transaction有三个函数，分别为my_print、my_copy以及my_compare函数。使用UVM中的field_automation机制可以将以上三个函数进行整合，该机制使用uvm_field系列宏实现：\n```java\n   `uvm_object_utils_begin(my_transaction)\n      `uvm_field_int(dmac, UVM_ALL_ON)\n      `uvm_field_int(smac, UVM_ALL_ON)\n      `uvm_field_int(ether_type, UVM_ALL_ON)\n      `uvm_field_array_int(pload, UVM_ALL_ON)\n      `uvm_field_int(crc, UVM_ALL_ON)\n   `uvm_object_utils_end\n```\n这里使用uvm_object_utils_begin和uvm_object_utils_end来实现my_transaction的factory注册，在这两个宏中间，使用uvm_field宏注册所有字段。通过这样的操作可以直接调用copy、compare、print等函数，而无需自己定义。\n引入field_automation机制的另外一大好处是简化driver和monitor。my_driver的drv_one_pkt任务和  my_monitor的collect_one_pkt任务代码很长，其作用主要是将数据通过tran连接到DUT上。使用field_automation机制后，drv_one_pkt任务可以简化为:\n```java\ntask my_driver::drive_one_pkt(my_transaction tr);\n   byte unsigned     data_q[];\n   int  data_size;\n   \n   data_size = tr.pack_bytes(data_q) / 8; \n   `uvm_info(\"my_driver\", \"begin to drive one pkt\", UVM_LOW);\n   repeat(3) @(posedge vif.clk);\n   for ( int i = 0; i < data_size; i++ ) begin\n      @(posedge vif.clk);\n      vif.valid <= 1'b1;\n      vif.data <= data_q[i]; \n   end\n\n   @(posedge vif.clk);\n   vif.valid <= 1'b0;\n   `uvm_info(\"my_driver\", \"end drive one pkt\", UVM_LOW);\nendtask\n```\n其中调用pack_bytes将tr中所有的字段变成byte流放入data_q中，减少了代码量。同理，在monitor中的解析也是这样：\n```java\ntask my_monitor::collect_one_pkt(my_transaction tr);\n   byte unsigned data_q[$];\n   byte unsigned data_array[];\n   logic [7:0] data;\n   logic valid = 0;\n   int data_size;\n   \n   while(1) begin\n      @(posedge vif.clk);\n      if(vif.valid) break;\n   end\n   \n   `uvm_info(\"my_monitor\", \"begin to collect one pkt\", UVM_LOW);\n   while(vif.valid) begin\n      data_q.push_back(vif.data);\n      @(posedge vif.clk);\n   end\n   data_size  = data_q.size();   \n   data_array = new[data_size];\n   for ( int i = 0; i < data_size; i++ ) begin\n      data_array[i] = data_q[i]; \n   end\n   tr.pload = new[data_size - 18]; //da sa, e_type, crc\n   data_size = tr.unpack_bytes(data_array) / 8; \n   `uvm_info(\"my_monitor\", \"end collect one pkt\", UVM_LOW);\nendtask\n```\n这里使用unpack_bytes函数将data_q中的byte流转换成tr中的各个字段。但是这里值得注意的是，unpack_bytes函数的输入参数必须是一个动态数组，所以需要先把收集到的数据放在data_q中的数据复制到一个动态数组中。==由于tr中的pload是一个动态数组,所以需要在调用 unpack_bytes 之前指定其大小,这样unpack_bytes函数才能正常工作（这里看不太懂）==。\n# 七、sequence组件\nsequence实际上就是一个产生激励的工具，在之前激励都是由my_dirver产生的，这次变为了sequence。在  一个规范化的UVM验证平台中,driver只负责驱动transaction,而不负责产生transaction。sequence机制有两大组成部分,一是  sequence,二是sequencer。\n## 7.1 sequencer\n下面是sequencer的代码部分：\n```java\nclass my_sequencer extends uvm_sequencer #(my_transaction);\n   \n   function new(string name, uvm_component parent);\n      super.new(name, parent);\n   endfunction \n   \n   `uvm_component_utils(my_sequencer)\nendclass\n```\n可以看到，uvm_sequencer是一个参数化的类,其参数是my_transaction，即此sequencer产生的transaction的类型。但是，我们上文中的dirver其实也是参数化的类，应该在定义driver时指明此driver要驱动的transaction的类型:\n```java\nclass my_driver extends uvm_driver#(my_transaction);\n```\n这样定义的好处是可以直接使用uvm_driver中的某些预先定义好的成员变量，如uvm_driver中有成员变量req，它的类型就是传递给uvm_driver的参数，在这里就是my_transaction，可以直接使用req：\n```java\ntask my_driver::main_phase(uvm_phase phase);\n   phase.raise_objection(this);\n   vif.data <= 8'b0;\n   vif.valid <= 1'b0;\n   while(!vif.rst_n)\n      @(posedge vif.clk);\n   for(int i = 0; i < 2; i++) begin \n      req = new(\"req\");\n      assert(req.randomize() with {pload.size == 200;});\n      drive_one_pkt(req);\n   end\n   repeat(5) @(posedge vif.clk);\n   phase.drop_objection(this);\nendtask\n```\n然后将该模块加入agent，得到的图如下所示：\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/2ab39f73831e4e808ae5b1078371900a.png\" height=250 >\n</div>\n\n## 7.2 sequence机制\n下面是前面提到的整个UVM的结构图，可以看见sequence的位置在比较偏的地方。这说明sequence并不是一个company而是一个object。\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/1c725a18ebd84ac3990ca2f08ca1050d.png\" height=250 >\n</div>\n\n其代码如下：\n```java\nclass my_sequence extends uvm_sequence #(my_transaction);\n   my_transaction m_trans;\n   function new(string name= \"my_sequence\");\n      super.new(name);\n   endfunction\n   virtual task body();\n      repeat (10) begin\n         `uvm_do(m_trans)\n      end\n      #1000;\n   endtask\n   `uvm_object_utils(my_sequence)\nendclass\n```\n可以看出，该模块在定义时同样要指定产生的transaction的类型，这里是my_transaction。每一个sequence都有一个body任务，当一个sequence启动之后，会自动执行body中的代码。\n在上面的例子中，用到了uvm_do，其作用为：\n- 创建一个my_transaction的实例m_trans\n- 将其随机化\n- 最终将其送给sequencer\n\n下一步就是要将uvm_driver和uvm_sequencer以及uvm_sequencer和uvm_sequencer连接起来。\n在uvm_driver中有成员变量seq_item_port，而在uvm_sequencer中有成员变量seq_item_export，这两者之间可以建立一个“通道”，通道中传递的transaction类型就是定义my_sequencer和my_driver时指定的transaction类型。因此在my_agent中,  使用connect函数把两者联系在一起：\n```java\nfunction void my_agent::connect_phase(uvm_phase phase);\n   super.connect_phase(phase);\n   if (is_active == UVM_ACTIVE) begin\n      drv.seq_item_port.connect(sqr.seq_item_export);\n   end\n   ap = mon.ap;\nendfunction\n```\n链接之后，dirver就可以向sequencer申请。代码如下：\n```java\ntask my_driver::main_phase(uvm_phase phase);\n   vif.data <= 8'b0;\n   vif.valid <= 1'b0;\n   while(!vif.rst_n)\n      @(posedge vif.clk);\n   while(1) begin\n      seq_item_port.get_next_item(req);\n      drive_one_pkt(req);\n      seq_item_port.item_done();\n   end\nendtask\n```\n在如上的代码中，通过get_next_item任务来得到一个新的req,并且驱动它,驱动完成后调用item_done通知sequencer。这里为什么会有一个item_done呢，其主要作用就是让sequencer知道dirver已经接收到了这个req，形成一个类似于握手的机制。\nuvm_do宏产生了一个transaction并交给sequencer，driver取走这个transaction后，uvm_do并不会立刻返回执行下一次的uvm_do宏，而是等待在那里，直到driver返回item_done信号。此时，uvm_do宏才算是执行完毕，返回后开始执行下一个uvm_do，并产生新的transaction。\n\n然后就是最后一个问题就是将uvm_sequencer和uvm_sequencer连接起来，可以直接在UVM的根部进行定义：\n```java\ntask my_env::main_phase(uvm_phase phase);\n   my_sequence seq;\n   phase.raise_objection(this);\n   seq = my_sequence::type_id::create(\"seq\");\n   seq.start(i_agt.sqr); \n   phase.drop_objection(this);\nendtask\n```\n首先创建一个my_sequence的实例seq，之后调用start任务。start任务的参数是一个sequencer指针。\n当然其实还有另一种方法来让dirver获得tran，就是使用try_next_item函数，上文中的get_next_item是阻塞的，而try_next_item则是非阻塞的，这样大大提高了代码的灵活性。\n```java\ntask my_driver::main_phase(uvm_phase phase);\n\t vif.data <= 8'b0; \n\t vif.valid <= 1'b0; \n\t while(!vif.rst_n) \n\t\t @(posedge vif.clk); \n \twhile(1)  begin \n \t\tseq_item_port.try_next_item(req);\n \t\t if(req == null) \n  \t\t\t@(posedge vif.clk); \n  \t\telse begin \n \t\t\t drive_one_pkt(req); \n \t\t seq_item_port.item_done();\n  \t end \n   end\nendtask\n```\n## 7.3 default_sequence机制\n在刚才，sequence是在my_env的main_phase中手工启动的，但是在实际应用中,  使用最多的还是通过default_sequence的方式启动sequence。default_sequence的启动方式很简单，只需要在任意地方加入如下代码（以my_env举例）：\n```java\n      uvm_config_db#(uvm_object_wrapper)::set(this,\n                                              \"i_agt.sqr.main_phase\",\n                                              \"default_sequence\",\n                                               my_sequence::type_id::get());\n```\n该代码同样使用了uvm_config_db，但是这里是在类里面调用的，第二个参数是相对于第一个参数的相对路径，由于上述代码是在my_env中，所以第二个参数中就不需  要uvm_test_top了。在top_tb中设置virtual interface时,由于top_tb不是一个类，无法使用this指针，所以设置set的第一个参数为null，并且第二个参数使用绝对路径uvm_test_top.xxx。\n在第二个路径参数中，出现了main_phase。这是因为该代码是在这个位置的main_phase启动的。\n至于set的第三个和第四个参数，书上说记住就行。\n还有一个问题就是，在上一节启动sequence前后，分别提起和撤销objection,这里也需要加上这两个操作。sequencer在启动default_sequence时，会自动将自己传给sequence的starting_phase，因此可以这样写：\n```java\n   virtual task body();\n      if(starting_phase != null) \n         starting_phase.raise_objection(this);\n      repeat (10) begin\n         `uvm_do(m_trans)\n      end\n      #1000;\n      if(starting_phase != null) \n         starting_phase.drop_objection(this);\n   endtask\n```\nok，结束。\n# 八、bast_test组件\n没想到吧，其实uvm的树根不是env，而是这个东西。该模块的代码如下：\n```java\nclass base_test extends uvm_test;\n\n   my_env         env;\n   \n   function new(string name = \"base_test\", uvm_component parent = null);\n      super.new(name,parent);\n   endfunction\n   \n   extern virtual function void build_phase(uvm_phase phase);\n   extern virtual function void report_phase(uvm_phase phase);\n   `uvm_component_utils(base_test)\nendclass\n\n\nfunction void base_test::build_phase(uvm_phase phase);\n   super.build_phase(phase);\n   env  =  my_env::type_id::create(\"env\", this); \n   uvm_config_db#(uvm_object_wrapper)::set(this,\n                                           \"env.i_agt.sqr.main_phase\",\n                                           \"default_sequence\",\n                                            my_sequence::type_id::get());\nendfunction\n\nfunction void base_test::report_phase(uvm_phase phase);\n   uvm_report_server server;\n   int err_num;\n   super.report_phase(phase);\n\n   server = get_report_server();\n   err_num = server.get_severity_count(UVM_ERROR);\n\n   if (err_num != 0) begin\n      $display(\"TEST CASE FAILED\");\n   end\n   else begin\n      $display(\"TEST CASE PASSED\");\n   end\nendfunction\n```\n代码很常规，但需要注意的是，这里设置了default_sequence，其他地方就不需要再设置了。 \n上面的代码中出现了report_phase，在report_phase中根据UVM_ERROR的数量来打印不同的信息，其在main_phase结束之后执行。 \n除了上述操作外，还通常在base_test中做如下事情：\n- 设置整个验证平台的超时退出时间;\n- 通过config_db设置验证平台中某些参数的值。\n\n最终得到的树形结构如下所示：\n\n<div align=center>\n<img src=\"https://i-blog.csdnimg.cn/direct/3f0c6de493004bbd9af7eb0ae15fa890.png\" height=250 >\n</div>\n\n# 九、总结\n到现在为止，一个基本的UVM结构已经完全构建完毕了，后面我会继续为大家分享uvm的相关知识以及项目。谢谢大家支持！！！\n","tags":["UVM"],"categories":["UVM学习笔记"]}]